#!/usr/bin/env python3.8
# @generated by pegen from C:\Users\kchon\OneDrive\Desktop\ast_lib\scripts\data\match.gram
# pyright: reportUnusedVariable=false, reportUnusedImport=false, reportIncompatibleMethodOverride=false, reportUnusedParameter=false
# ruff: noqa: F401, F841, E703, F405, F403, F634

from __future__ import annotations


import ast
import sys
import tokenize

from typing import Any, Optional, TYPE_CHECKING, cast

from rich import print
from pegen.parser import memoize, memoize_left_rec, logger, Parser
from functools import reduce, wraps
from .parser_helpers import *
from .nodes import *

def wrap_start(fn):
    @wraps(fn)
    def wrapper(self, *args, **kwargs):
        ret = fn(self, *args, **kwargs)
        return ret
    return wrapper

def wrap_stmt(fn):
    @wraps(fn)
    def wrapper(self, *args, **kwargs):
        lineno = self._tokenizer.peek().start[0]
        ret = fn(self, *args, **kwargs)
        return ret
    return wrapper

def _reduce_chain(p, s):
    def reducer(acc, suffix):
        if suffix['type'] == 'Call':
            return Call(func=acc, args=suffix['args'])
        if suffix['type'] == 'Attribute':
            return Attribute(value=acc, attr=suffix['attr'])
        if suffix['type'] == 'Subscript':
            return Subscript(value=acc, slice=suffix['slice'])
        return acc
    
    return reduce(reducer, s, p)

def _make_dict(head, tail):
    return tuple(zip(*[head] + [(k, v) for _, k, __, v in tail]))


# Keywords and soft keywords are listed at the end of the parser definition.
class DSLParser(Parser):

    @memoize
    def todo(self) -> Optional[Any]:
        # todo: 'todo'
        mark = self._mark()
        if (
            (self.expect('todo'))
        ):
            return _Todo ( );
        self._reset(mark)
        return None;

    @wrap_start
    @memoize
    def start(self) -> Optional[Any]:
        # start: stmts $
        mark = self._mark()
        if (
            (stmts := self.stmts())
            and
            (self.expect('ENDMARKER'))
        ):
            return stmts;
        self._reset(mark)
        return None;

    @memoize
    def stmts(self) -> Optional[list [stmt]]:
        # stmts: stmt '\n' stmts | stmt '\n' | stmt
        mark = self._mark()
        if (
            (s := self.stmt())
            and
            (self.expect('\n'))
            and
            (rest := self.stmts())
        ):
            return [s , * rest];
        self._reset(mark)
        if (
            (s := self.stmt())
            and
            (self.expect('\n'))
        ):
            return [s];
        self._reset(mark)
        if (
            (s := self.stmt())
        ):
            return [s];
        self._reset(mark)
        return None;

    @wrap_stmt
    @memoize
    def stmt(self) -> Optional[stmt]:
        # stmt: function_def | async_function_def | class_def | return_stmt | delete_stmt | assign | ann_assign | for_stmt | async_for | while_stmt | if_stmt | expr_stmt
        mark = self._mark()
        if (
            (function_def := self.function_def())
        ):
            return function_def;
        self._reset(mark)
        if (
            (async_function_def := self.async_function_def())
        ):
            return async_function_def;
        self._reset(mark)
        if (
            (class_def := self.class_def())
        ):
            return class_def;
        self._reset(mark)
        if (
            (return_stmt := self.return_stmt())
        ):
            return return_stmt;
        self._reset(mark)
        if (
            (delete_stmt := self.delete_stmt())
        ):
            return delete_stmt;
        self._reset(mark)
        if (
            (assign := self.assign())
        ):
            return assign;
        self._reset(mark)
        if (
            (ann_assign := self.ann_assign())
        ):
            return ann_assign;
        self._reset(mark)
        if (
            (for_stmt := self.for_stmt())
        ):
            return for_stmt;
        self._reset(mark)
        if (
            (async_for := self.async_for())
        ):
            return async_for;
        self._reset(mark)
        if (
            (while_stmt := self.while_stmt())
        ):
            return while_stmt;
        self._reset(mark)
        if (
            (if_stmt := self.if_stmt())
        ):
            return if_stmt;
        self._reset(mark)
        if (
            (expr_stmt := self.expr_stmt())
        ):
            return expr_stmt;
        self._reset(mark)
        return None;

    @memoize
    def function_def(self) -> Optional[FunctionDef]:
        # function_def: 'def' id type_params? '(' params? ')' ['->' expression] ':' '...'
        mark = self._mark()
        if (
            (self.expect('def'))
            and
            (n := self.id())
            and
            (self.type_params(),)
            and
            (self.expect('('))
            and
            (params := self.params(),)
            and
            (self.expect(')'))
            and
            (self._tmp_1(),)
            and
            (self.expect(':'))
            and
            (self.expect('...'))
        ):
            return FunctionDef ( name = n , decorator_list = [] , args = params or arguments . make_empty ( ) );
        self._reset(mark)
        return None;

    @memoize
    def async_function_def(self) -> Optional[AsyncFunctionDef]:
        # async_function_def: decorators? 'async' 'def' id '(' params? ')' ellipsis?
        mark = self._mark()
        if (
            (d := self.decorators(),)
            and
            (self.expect('async'))
            and
            (self.expect('def'))
            and
            (n := self.id())
            and
            (self.expect('('))
            and
            (a := self.params(),)
            and
            (self.expect(')'))
            and
            (self.ellipsis(),)
        ):
            return AsyncFunctionDef ( name = n , decorator_list = d or [] , args = a or arguments . make_empty ( ) );
        self._reset(mark)
        return None;

    @memoize
    def class_def(self) -> Optional[ClassDef]:
        # class_def: decorators? 'class' id class_bases? ellipsis?
        mark = self._mark()
        if (
            (d := self.decorators(),)
            and
            (self.expect('class'))
            and
            (n := self.id())
            and
            (bases := self.class_bases(),)
            and
            (self.ellipsis(),)
        ):
            return ClassDef ( name = n , bases = bases or [] , decorator_list = d or [] );
        self._reset(mark)
        return None;

    @memoize
    def return_stmt(self) -> Optional[Return]:
        # return_stmt: 'return' expr
        mark = self._mark()
        if (
            (self.expect('return'))
            and
            (e := self.expr())
        ):
            return Return ( value = e );
        self._reset(mark)
        return None;

    @memoize
    def delete_stmt(self) -> Optional[Delete]:
        # delete_stmt: 'delete' exprs
        mark = self._mark()
        if (
            (self.expect('delete'))
            and
            (e := self.exprs())
        ):
            return Delete ( targets = e );
        self._reset(mark)
        return None;

    @memoize
    def assign(self) -> Optional[Assign]:
        # assign: exprs '=' expr
        mark = self._mark()
        if (
            (targets := self.exprs())
            and
            (self.expect('='))
            and
            (value := self.expr())
        ):
            return Assign ( targets = targets , value = value );
        self._reset(mark)
        return None;

    @memoize
    def ann_assign(self) -> Optional[AnnAssign]:
        # ann_assign: expr ':' expr '=' expr
        mark = self._mark()
        if (
            (target := cast(Name | Attribute | Subscript, self.expr()))
            and
            (self.expect(':'))
            and
            (ann := self.expr())
            and
            (self.expect('='))
            and
            (value := self.expr())
        ):
            return AnnAssign ( target = target , annotation = ann , value = value );
        self._reset(mark)
        return None;

    @memoize
    def for_stmt(self) -> Optional[For]:
        # for_stmt: 'for' expr 'in' expr ellipsis?
        mark = self._mark()
        if (
            (self.expect('for'))
            and
            (target := self.expr())
            and
            (self.expect('in'))
            and
            (iter := self.expr())
            and
            (self.ellipsis(),)
        ):
            return For ( target = target , iter = iter );
        self._reset(mark)
        return None;

    @memoize
    def async_for(self) -> Optional[AsyncFor]:
        # async_for: 'async' 'for' expr 'in' expr ellipsis?
        mark = self._mark()
        if (
            (self.expect('async'))
            and
            (self.expect('for'))
            and
            (target := self.expr())
            and
            (self.expect('in'))
            and
            (iter := self.expr())
            and
            (self.ellipsis(),)
        ):
            return AsyncFor ( target = target , iter = iter );
        self._reset(mark)
        return None;

    @memoize
    def while_stmt(self) -> Optional[While]:
        # while_stmt: 'while' expr ellipsis?
        mark = self._mark()
        if (
            (self.expect('while'))
            and
            (test := self.expr())
            and
            (self.ellipsis(),)
        ):
            return While ( test = test );
        self._reset(mark)
        return None;

    @memoize
    def if_stmt(self) -> Optional[If]:
        # if_stmt: 'if' expr [('=' ellipsis?)]
        mark = self._mark()
        if (
            (self.expect('if'))
            and
            (test := self.expr())
            and
            (self._tmp_2(),)
        ):
            return If ( test = test );
        self._reset(mark)
        return None;

    @memoize
    def expr_stmt(self) -> Optional[Expr]:
        # expr_stmt: expr
        mark = self._mark()
        if (
            (e := self.expr())
        ):
            return Expr ( value = e );
        self._reset(mark)
        return None;

    @memoize
    def decorators(self) -> Optional[list [ASTPattern [expr]]]:
        # decorators: '\n'.decorator+
        mark = self._mark()
        if (
            (_gather_3 := self._gather_3())
        ):
            return _gather_3;
        self._reset(mark)
        return None;

    @memoize
    def decorator(self) -> Optional[ASTPattern [expr]]:
        # decorator: '@' expr
        mark = self._mark()
        if (
            (self.expect('@'))
            and
            (e := self.expr())
        ):
            return e;
        self._reset(mark)
        return None;

    @memoize
    def class_bases(self) -> Optional[list [ASTPattern [expr]]]:
        # class_bases: '(' exprs ')'
        mark = self._mark()
        if (
            (self.expect('('))
            and
            (e := self.exprs())
            and
            (self.expect(')'))
        ):
            return e;
        self._reset(mark)
        return None;

    @memoize
    def ellipsis(self) -> Optional[Any]:
        # ellipsis: ':' '...' | ':'
        mark = self._mark()
        if (
            (literal := self.expect(':'))
            and
            (literal_1 := self.expect('...'))
        ):
            return [literal, literal_1];
        self._reset(mark)
        if (
            (literal := self.expect(':'))
        ):
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def type_params(self) -> Optional[list [ASTPattern [expr]]]:
        # type_params: todo
        mark = self._mark()
        if (
            (todo := self.todo())
        ):
            return todo;
        self._reset(mark)
        return None;

    @memoize
    def params(self) -> Optional[ASTPattern [arguments]]:
        # params: parameters
        mark = self._mark()
        if (
            (parameters := self.parameters())
        ):
            return parameters;
        self._reset(mark)
        return None;

    @memoize
    def parameters(self) -> Optional[ASTPattern [arguments]]:
        # parameters: slash_no_default param_no_default* param_with_default* star_etc? | slash_with_default param_with_default* star_etc? | param_no_default+ param_with_default* star_etc? | param_with_default+ star_etc? | star_etc
        mark = self._mark()
        if (
            (a := self.slash_no_default())
            and
            (b := self._loop0_5(),)
            and
            (c := self._loop0_6(),)
            and
            (d := self.star_etc(),)
        ):
            return make_arguments ( slash_without_default = a , plain_names = b , names_with_default = c , star_etc = d , );
        self._reset(mark)
        if (
            (a := self.slash_with_default())
            and
            (b := self._loop0_7(),)
            and
            (c := self.star_etc(),)
        ):
            return make_arguments ( slash_with_default = a , names_with_default = b , star_etc = c , );
        self._reset(mark)
        if (
            (a := self._loop1_8())
            and
            (b := self._loop0_9(),)
            and
            (c := self.star_etc(),)
        ):
            return make_arguments ( plain_names = a , names_with_default = b , star_etc = c , );
        self._reset(mark)
        if (
            (a := self._loop1_10())
            and
            (b := self.star_etc(),)
        ):
            return make_arguments ( names_with_default = a , star_etc = b , );
        self._reset(mark)
        if (
            (a := self.star_etc())
        ):
            return make_arguments ( star_etc = a );
        self._reset(mark)
        return None;

    @memoize
    def slash_no_default(self) -> Optional[list [arg]]:
        # slash_no_default: param_no_default+ '/' ',' | param_no_default+ '/' &')'
        mark = self._mark()
        if (
            (a := self._loop1_11())
            and
            (self.expect('/'))
            and
            (self.expect(','))
        ):
            return a;
        self._reset(mark)
        if (
            (a := self._loop1_12())
            and
            (self.expect('/'))
            and
            (self.positive_lookahead(self.expect, ')'))
        ):
            return a;
        self._reset(mark)
        return None;

    @memoize
    def slash_with_default(self) -> Optional[SlashWithDefault]:
        # slash_with_default: param_no_default* param_with_default+ '/' ',' | param_no_default* param_with_default+ '/' &')'
        mark = self._mark()
        if (
            (a := self._loop0_13(),)
            and
            (b := self._loop1_14())
            and
            (self.expect('/'))
            and
            (self.expect(','))
        ):
            return SlashWithDefault ( a , b );
        self._reset(mark)
        if (
            (a := self._loop0_15(),)
            and
            (b := self._loop1_16())
            and
            (self.expect('/'))
            and
            (self.positive_lookahead(self.expect, ')'))
        ):
            return SlashWithDefault ( a , b );
        self._reset(mark)
        return None;

    @memoize
    def star_etc(self) -> Optional[StarEtc]:
        # star_etc: '*' param_no_default param_maybe_default* kwds? | '*' param_no_default_star_annotation param_maybe_default* kwds? | '*' ',' param_maybe_default+ kwds? | kwds
        mark = self._mark()
        if (
            (self.expect('*'))
            and
            (a := self.param_no_default())
            and
            (b := self._loop0_17(),)
            and
            (c := self.kwds(),)
        ):
            return StarEtc ( a , b , c );
        self._reset(mark)
        if (
            (self.expect('*'))
            and
            (a := self.param_no_default_star_annotation())
            and
            (b := self._loop0_18(),)
            and
            (c := self.kwds(),)
        ):
            return StarEtc ( a , b , c );
        self._reset(mark)
        if (
            (self.expect('*'))
            and
            (self.expect(','))
            and
            (b := self._loop1_19())
            and
            (c := self.kwds(),)
        ):
            return StarEtc ( None , b , c );
        self._reset(mark)
        if (
            (a := self.kwds())
        ):
            return StarEtc ( None , [] , a );
        self._reset(mark)
        return None;

    @memoize
    def kwds(self) -> Optional[ASTPattern [arg]]:
        # kwds: '**' param_no_default
        mark = self._mark()
        if (
            (self.expect('**'))
            and
            (a := self.param_no_default())
        ):
            return a;
        self._reset(mark)
        return None;

    @memoize
    def param_no_default(self) -> Optional[ASTPattern [arg]]:
        # param_no_default: param ',' | param &')'
        mark = self._mark()
        if (
            (a := self.param())
            and
            (self.expect(','))
        ):
            return a;
        self._reset(mark)
        if (
            (a := self.param())
            and
            (self.positive_lookahead(self.expect, ')'))
        ):
            return a;
        self._reset(mark)
        return None;

    @memoize
    def param_no_default_star_annotation(self) -> Optional[ASTPattern [arg]]:
        # param_no_default_star_annotation: param_star_annotation ',' | param_star_annotation &')'
        mark = self._mark()
        if (
            (a := self.param_star_annotation())
            and
            (self.expect(','))
        ):
            return a;
        self._reset(mark)
        if (
            (a := self.param_star_annotation())
            and
            (self.positive_lookahead(self.expect, ')'))
        ):
            return a;
        self._reset(mark)
        return None;

    @memoize
    def param_with_default(self) -> Optional[NameDefaultPair]:
        # param_with_default: param default ',' | param default &')'
        mark = self._mark()
        if (
            (a := self.param())
            and
            (c := self.default())
            and
            (self.expect(','))
        ):
            return NameDefaultPair ( a , c );
        self._reset(mark)
        if (
            (a := self.param())
            and
            (c := self.default())
            and
            (self.positive_lookahead(self.expect, ')'))
        ):
            return NameDefaultPair ( a , c );
        self._reset(mark)
        return None;

    @memoize
    def param_maybe_default(self) -> Optional[NameDefaultPair]:
        # param_maybe_default: param default? ',' | param default? &')'
        mark = self._mark()
        if (
            (a := self.param())
            and
            (c := self.default(),)
            and
            (self.expect(','))
        ):
            return NameDefaultPair ( a , c );
        self._reset(mark)
        if (
            (a := self.param())
            and
            (c := self.default(),)
            and
            (self.positive_lookahead(self.expect, ')'))
        ):
            return NameDefaultPair ( a , c );
        self._reset(mark)
        return None;

    @memoize
    def param(self) -> Optional[ASTPattern [arg]]:
        # param: NAME annotation?
        mark = self._mark()
        if (
            (a := self.name())
            and
            (b := self.annotation(),)
        ):
            return arg ( arg = a . string , annotation = b or Wildcard ( ) );
        self._reset(mark)
        return None;

    @memoize
    def param_star_annotation(self) -> Optional[ASTPattern [arg]]:
        # param_star_annotation: todo
        mark = self._mark()
        if (
            (todo := self.todo())
        ):
            return todo;
        self._reset(mark)
        return None;

    @memoize
    def annotation(self) -> Optional[ASTPattern [expr]]:
        # annotation: ':' expression
        mark = self._mark()
        if (
            (self.expect(':'))
            and
            (a := self.expression())
        ):
            return a;
        self._reset(mark)
        return None;

    @memoize
    def star_annotation(self) -> Optional[ASTPattern [expr]]:
        # star_annotation: todo
        mark = self._mark()
        if (
            (todo := self.todo())
        ):
            return todo;
        self._reset(mark)
        return None;

    @memoize
    def default(self) -> Optional[ASTPattern [expr]]:
        # default: '=' expression
        mark = self._mark()
        if (
            (self.expect('='))
            and
            (a := self.expression())
        ):
            return a;
        self._reset(mark)
        return None;

    @memoize
    def exprs(self) -> Optional[list [ASTPattern [expr]]]:
        # exprs: wildcards0 | wildcards1 | !(expr ','? ')') '$' NAME '{' (exprs) '}' | !(expr ','? ')') '$' NUMBER '{' (exprs) '}' | ','.expr+ ','?
        mark = self._mark()
        if (
            (self.wildcards0())
        ):
            return WildcardRepeat0 ( );
        self._reset(mark)
        if (
            (self.wildcards1())
        ):
            return WildcardRepeat1 ( );
        self._reset(mark)
        if (
            (self.negative_lookahead(self._tmp_20, ))
            and
            (self.expect('$'))
            and
            (n := self.name())
            and
            (self.expect('{'))
            and
            (pattern := self.exprs())
            and
            (self.expect('}'))
        ):
            return Capture ( name = n . string , pattern = pattern );
        self._reset(mark)
        if (
            (self.negative_lookahead(self._tmp_21, ))
            and
            (self.expect('$'))
            and
            (n := self.number())
            and
            (self.expect('{'))
            and
            (pattern := self.exprs())
            and
            (self.expect('}'))
        ):
            return Capture ( name = int ( n . string ) , pattern = pattern );
        self._reset(mark)
        if (
            (a := cast(list [ASTPattern [expr]], self._gather_22()))
            and
            (self.expect(','),)
        ):
            return a;
        self._reset(mark)
        return None;

    @memoize
    def expr(self) -> Optional[ASTPattern [expr]]:
        # expr: disjunction 'if' disjunction 'else' expr | disjunction | lambdef
        mark = self._mark()
        if (
            (a := self.disjunction())
            and
            (self.expect('if'))
            and
            (b := self.disjunction())
            and
            (self.expect('else'))
            and
            (c := self.expr())
        ):
            return IfExp ( a , b , c );
        self._reset(mark)
        if (
            (disjunction := self.disjunction())
        ):
            return disjunction;
        self._reset(mark)
        if (
            (lambdef := self.lambdef())
        ):
            return lambdef;
        self._reset(mark)
        return None;

    @memoize
    def expression(self) -> Optional[Any]:
        # expression: expr
        mark = self._mark()
        if (
            (expr := self.expr())
        ):
            return expr;
        self._reset(mark)
        return None;

    @memoize
    def yield_expr(self) -> Optional[ASTPattern [expr]]:
        # yield_expr: 'yield' 'from' expr | 'yield' star_exprs?
        mark = self._mark()
        if (
            (self.expect('yield'))
            and
            (self.expect('from'))
            and
            (a := self.expr())
        ):
            return YieldFrom ( a );
        self._reset(mark)
        if (
            (self.expect('yield'))
            and
            (a := self.star_exprs(),)
        ):
            return Yield ( a );
        self._reset(mark)
        return None;

    @memoize
    def star_exprs(self) -> Optional[list [ASTPattern [expr]]]:
        # star_exprs: exprs ','
        mark = self._mark()
        if (
            (a := self.exprs())
            and
            (self.expect(','))
        ):
            return a;
        self._reset(mark)
        return None;

    @memoize
    def star_expr(self) -> Optional[ASTPattern [expr]]:
        # star_expr: '*' bitwise_or | expr
        mark = self._mark()
        if (
            (self.expect('*'))
            and
            (a := self.bitwise_or())
        ):
            return Starred ( a );
        self._reset(mark)
        if (
            (expr := self.expr())
        ):
            return expr;
        self._reset(mark)
        return None;

    @memoize
    def star_named_exprs(self) -> Optional[list [ASTPattern [expr]]]:
        # star_named_exprs: ','.star_named_expr+ ','?
        mark = self._mark()
        if (
            (a := cast(list [ASTPattern [expr]], self._gather_24()))
            and
            (self.expect(','),)
        ):
            return a;
        self._reset(mark)
        return None;

    @memoize
    def star_named_expr(self) -> Optional[ASTPattern [expr]]:
        # star_named_expr: '*' bitwise_or | named_expr
        mark = self._mark()
        if (
            (self.expect('*'))
            and
            (a := self.bitwise_or())
        ):
            return Starred ( a );
        self._reset(mark)
        if (
            (named_expr := self.named_expr())
        ):
            return named_expr;
        self._reset(mark)
        return None;

    @memoize
    def assignment_expr(self) -> Optional[ASTPattern [expr]]:
        # assignment_expr: NAME ':=' ~ expr
        mark = self._mark()
        cut = False
        if (
            (a := self.name())
            and
            (self.expect(':='))
            and
            (cut := True)
            and
            (b := self.expr())
        ):
            return NamedExpr ( target = a , value = b );
        self._reset(mark)
        if cut:
            return None;
        return None;

    @memoize
    def named_expr(self) -> Optional[ASTPattern [expr]]:
        # named_expr: assignment_expr | expr !':='
        mark = self._mark()
        if (
            (assignment_expr := self.assignment_expr())
        ):
            return assignment_expr;
        self._reset(mark)
        if (
            (expr := self.expr())
            and
            (self.negative_lookahead(self.expect, ':='))
        ):
            return expr;
        self._reset(mark)
        return None;

    @memoize
    def disjunction(self) -> Optional[ASTPattern [expr]]:
        # disjunction: conjunction (('or' conjunction))+ | conjunction
        mark = self._mark()
        if (
            (a := self.conjunction())
            and
            (b := self._loop1_26())
        ):
            return BoolOp ( op = Or ( ) , values = [a , * b] );
        self._reset(mark)
        if (
            (conjunction := self.conjunction())
        ):
            return conjunction;
        self._reset(mark)
        return None;

    @memoize
    def conjunction(self) -> Optional[ASTPattern [expr]]:
        # conjunction: inversion (('and' inversion))+ | inversion
        mark = self._mark()
        if (
            (a := self.inversion())
            and
            (b := self._loop1_27())
        ):
            return BoolOp ( op = And ( ) , values = [a , * b] );
        self._reset(mark)
        if (
            (inversion := self.inversion())
        ):
            return inversion;
        self._reset(mark)
        return None;

    @memoize
    def inversion(self) -> Optional[ASTPattern [expr]]:
        # inversion: 'not' inversion | comparison
        mark = self._mark()
        if (
            (self.expect('not'))
            and
            (a := self.inversion())
        ):
            return UnaryOp ( op = Not ( ) , operand = a );
        self._reset(mark)
        if (
            (comparison := self.comparison())
        ):
            return comparison;
        self._reset(mark)
        return None;

    @memoize
    def comparison(self) -> Optional[ASTPattern [expr]]:
        # comparison: bitwise_or compare_op_bitwise_or_pair+ | bitwise_or
        mark = self._mark()
        if (
            (a := self.bitwise_or())
            and
            (b := self._loop1_28())
        ):
            return Compare ( left = a , ops = [pair ['op'] for pair in b] , comparators = [pair ['comparator'] for pair in b] );
        self._reset(mark)
        if (
            (bitwise_or := self.bitwise_or())
        ):
            return bitwise_or;
        self._reset(mark)
        return None;

    @memoize
    def compare_op_bitwise_or_pair(self) -> Optional[dict]:
        # compare_op_bitwise_or_pair: '==' bitwise_or | '!=' bitwise_or | '<=' bitwise_or | '<' bitwise_or | '>=' bitwise_or | '>' bitwise_or | 'not' 'in' bitwise_or | 'in' bitwise_or | 'is' 'not' bitwise_or | 'is' bitwise_or
        mark = self._mark()
        if (
            (self.expect('=='))
            and
            (b := self.bitwise_or())
        ):
            return {'op' : Eq ( ) , 'comparator' : b};
        self._reset(mark)
        if (
            (self.expect('!='))
            and
            (b := self.bitwise_or())
        ):
            return {'op' : NotEq ( ) , 'comparator' : b};
        self._reset(mark)
        if (
            (self.expect('<='))
            and
            (b := self.bitwise_or())
        ):
            return {'op' : LtE ( ) , 'comparator' : b};
        self._reset(mark)
        if (
            (self.expect('<'))
            and
            (b := self.bitwise_or())
        ):
            return {'op' : Lt ( ) , 'comparator' : b};
        self._reset(mark)
        if (
            (self.expect('>='))
            and
            (b := self.bitwise_or())
        ):
            return {'op' : GtE ( ) , 'comparator' : b};
        self._reset(mark)
        if (
            (self.expect('>'))
            and
            (b := self.bitwise_or())
        ):
            return {'op' : Gt ( ) , 'comparator' : b};
        self._reset(mark)
        if (
            (self.expect('not'))
            and
            (self.expect('in'))
            and
            (b := self.bitwise_or())
        ):
            return {'op' : NotIn ( ) , 'comparator' : b};
        self._reset(mark)
        if (
            (self.expect('in'))
            and
            (b := self.bitwise_or())
        ):
            return {'op' : In ( ) , 'comparator' : b};
        self._reset(mark)
        if (
            (self.expect('is'))
            and
            (self.expect('not'))
            and
            (b := self.bitwise_or())
        ):
            return {'op' : IsNot ( ) , 'comparator' : b};
        self._reset(mark)
        if (
            (self.expect('is'))
            and
            (b := self.bitwise_or())
        ):
            return {'op' : Is ( ) , 'comparator' : b};
        self._reset(mark)
        return None;

    @memoize_left_rec
    def bitwise_or(self) -> Optional[ASTPattern [expr]]:
        # bitwise_or: bitwise_or '|' bitwise_xor | bitwise_xor
        mark = self._mark()
        if (
            (a := self.bitwise_or())
            and
            (self.expect('|'))
            and
            (b := self.bitwise_xor())
        ):
            return BinOp ( left = a , op = BitOr ( ) , right = b );
        self._reset(mark)
        if (
            (bitwise_xor := self.bitwise_xor())
        ):
            return bitwise_xor;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def bitwise_xor(self) -> Optional[ASTPattern [expr]]:
        # bitwise_xor: bitwise_xor '^' bitwise_and | bitwise_and
        mark = self._mark()
        if (
            (a := self.bitwise_xor())
            and
            (self.expect('^'))
            and
            (b := self.bitwise_and())
        ):
            return BinOp ( left = a , op = BitXor ( ) , right = b );
        self._reset(mark)
        if (
            (bitwise_and := self.bitwise_and())
        ):
            return bitwise_and;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def bitwise_and(self) -> Optional[ASTPattern [expr]]:
        # bitwise_and: bitwise_and '&' shift_expr | shift_expr
        mark = self._mark()
        if (
            (a := self.bitwise_and())
            and
            (self.expect('&'))
            and
            (b := self.shift_expr())
        ):
            return BinOp ( left = a , op = BitAnd ( ) , right = b );
        self._reset(mark)
        if (
            (shift_expr := self.shift_expr())
        ):
            return shift_expr;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def shift_expr(self) -> Optional[ASTPattern [expr]]:
        # shift_expr: shift_expr '<<' sum | shift_expr '>>' sum | sum
        mark = self._mark()
        if (
            (a := self.shift_expr())
            and
            (self.expect('<<'))
            and
            (b := self.sum())
        ):
            return BinOp ( left = a , op = LShift ( ) , right = b );
        self._reset(mark)
        if (
            (a := self.shift_expr())
            and
            (self.expect('>>'))
            and
            (b := self.sum())
        ):
            return BinOp ( left = a , op = RShift ( ) , right = b );
        self._reset(mark)
        if (
            (sum := self.sum())
        ):
            return sum;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def sum(self) -> Optional[ASTPattern [expr]]:
        # sum: sum '+' term | sum '-' term | term
        mark = self._mark()
        if (
            (a := self.sum())
            and
            (self.expect('+'))
            and
            (b := self.term())
        ):
            return BinOp ( left = a , op = Add ( ) , right = b );
        self._reset(mark)
        if (
            (a := self.sum())
            and
            (self.expect('-'))
            and
            (b := self.term())
        ):
            return BinOp ( left = a , op = Sub ( ) , right = b );
        self._reset(mark)
        if (
            (term := self.term())
        ):
            return term;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def term(self) -> Optional[ASTPattern [expr]]:
        # term: term '*' factor | term '/' factor | term '//' factor | term '%' factor | term '@' factor | factor
        mark = self._mark()
        if (
            (a := self.term())
            and
            (self.expect('*'))
            and
            (b := self.factor())
        ):
            return BinOp ( left = a , op = Mult ( ) , right = b );
        self._reset(mark)
        if (
            (a := self.term())
            and
            (self.expect('/'))
            and
            (b := self.factor())
        ):
            return BinOp ( left = a , op = Div ( ) , right = b );
        self._reset(mark)
        if (
            (a := self.term())
            and
            (self.expect('//'))
            and
            (b := self.factor())
        ):
            return BinOp ( left = a , op = FloorDiv ( ) , right = b );
        self._reset(mark)
        if (
            (a := self.term())
            and
            (self.expect('%'))
            and
            (b := self.factor())
        ):
            return BinOp ( left = a , op = Mod ( ) , right = b );
        self._reset(mark)
        if (
            (a := self.term())
            and
            (self.expect('@'))
            and
            (b := self.factor())
        ):
            return BinOp ( left = a , op = MatMult ( ) , right = b );
        self._reset(mark)
        if (
            (factor := self.factor())
        ):
            return factor;
        self._reset(mark)
        return None;

    @memoize
    def factor(self) -> Optional[ASTPattern [expr]]:
        # factor: '+' factor | '-' factor | power
        mark = self._mark()
        if (
            (self.expect('+'))
            and
            (a := self.factor())
        ):
            return UnaryOp ( op = UAdd ( ) , operand = a );
        self._reset(mark)
        if (
            (self.expect('-'))
            and
            (a := self.factor())
        ):
            return UnaryOp ( op = USub ( ) , operand = a );
        self._reset(mark)
        if (
            (power := self.power())
        ):
            return power;
        self._reset(mark)
        return None;

    @memoize
    def power(self) -> Optional[ASTPattern [expr]]:
        # power: await_primary '**' factor | await_primary
        mark = self._mark()
        if (
            (a := self.await_primary())
            and
            (self.expect('**'))
            and
            (b := self.factor())
        ):
            return BinOp ( left = a , op = Pow ( ) , right = b );
        self._reset(mark)
        if (
            (await_primary := self.await_primary())
        ):
            return await_primary;
        self._reset(mark)
        return None;

    @memoize
    def await_primary(self) -> Optional[ASTPattern [expr]]:
        # await_primary: 'await' primary | primary
        mark = self._mark()
        if (
            (self.expect('await'))
            and
            (a := self.primary())
        ):
            return Await ( value = a );
        self._reset(mark)
        if (
            (primary := self.primary())
        ):
            return primary;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def primary(self) -> Optional[ASTPattern [expr]]:
        # primary: primary '.' id | primary '(' exprs? ')' | primary '[' expr ']' | atom
        mark = self._mark()
        if (
            (a := self.primary())
            and
            (self.expect('.'))
            and
            (b := self.id())
        ):
            return Attribute ( value = a , attr = b );
        self._reset(mark)
        if (
            (a := self.primary())
            and
            (self.expect('('))
            and
            (args := self.exprs(),)
            and
            (self.expect(')'))
        ):
            return Call ( func = a , args = args or [] );
        self._reset(mark)
        if (
            (a := self.primary())
            and
            (self.expect('['))
            and
            (b := self.expr())
            and
            (self.expect(']'))
        ):
            return Subscript ( value = a , slice = b );
        self._reset(mark)
        if (
            (atom := self.atom())
        ):
            return atom;
        self._reset(mark)
        return None;

    @memoize
    def atom(self) -> Optional[ASTPattern [expr]]:
        # atom: name_expr | constant | &'(' (tuple | group | genexp) | &'[' (list | listcomp) | &'{' (dict | set | dictcomp | setcomp) | wildcard | wildcard_id | capture_pattern | capture_id
        mark = self._mark()
        if (
            (name_expr := self.name_expr())
        ):
            return name_expr;
        self._reset(mark)
        if (
            (constant := self.constant())
        ):
            return constant;
        self._reset(mark)
        if (
            (self.positive_lookahead(self.expect, '('))
            and
            (_tmp_29 := self._tmp_29())
        ):
            return _tmp_29;
        self._reset(mark)
        if (
            (self.positive_lookahead(self.expect, '['))
            and
            (_tmp_30 := self._tmp_30())
        ):
            return _tmp_30;
        self._reset(mark)
        if (
            (self.positive_lookahead(self.expect, '{'))
            and
            (_tmp_31 := self._tmp_31())
        ):
            return _tmp_31;
        self._reset(mark)
        if (
            (wildcard := self.wildcard())
        ):
            return wildcard;
        self._reset(mark)
        if (
            (wildcard_id := self.wildcard_id())
        ):
            return wildcard_id;
        self._reset(mark)
        if (
            (c := self.capture_pattern())
        ):
            return c;
        self._reset(mark)
        if (
            (c := self.capture_id())
        ):
            return Capture ( name = c . name , pattern = expr ( ) );
        self._reset(mark)
        return None;

    @memoize
    def group(self) -> Optional[expr_ty]:
        # group: '(' (yield_expr | named_expr) ')'
        mark = self._mark()
        if (
            (self.expect('('))
            and
            (a := self._tmp_32())
            and
            (self.expect(')'))
        ):
            return a;
        self._reset(mark)
        return None;

    @memoize
    def lambdef(self) -> Optional[Any]:
        # lambdef: todo
        mark = self._mark()
        if (
            (todo := self.todo())
        ):
            return todo;
        self._reset(mark)
        return None;

    @memoize
    def genexp(self) -> Optional[Any]:
        # genexp: todo
        mark = self._mark()
        if (
            (todo := self.todo())
        ):
            return todo;
        self._reset(mark)
        return None;

    @memoize
    def listcomp(self) -> Optional[Any]:
        # listcomp: todo
        mark = self._mark()
        if (
            (todo := self.todo())
        ):
            return todo;
        self._reset(mark)
        return None;

    @memoize
    def setcomp(self) -> Optional[Any]:
        # setcomp: todo
        mark = self._mark()
        if (
            (todo := self.todo())
        ):
            return todo;
        self._reset(mark)
        return None;

    @memoize
    def dictcomp(self) -> Optional[Any]:
        # dictcomp: todo
        mark = self._mark()
        if (
            (todo := self.todo())
        ):
            return todo;
        self._reset(mark)
        return None;

    @memoize
    def constant(self) -> Optional[Constant]:
        # constant: 'None' | 'True' | 'False' | NUMBER | STRING | '...'
        mark = self._mark()
        if (
            (self.expect('None'))
        ):
            return Constant ( value = None );
        self._reset(mark)
        if (
            (self.expect('True'))
        ):
            return Constant ( value = True );
        self._reset(mark)
        if (
            (self.expect('False'))
        ):
            return Constant ( value = False );
        self._reset(mark)
        if (
            (n := self.number())
        ):
            return Constant ( value = ast . literal_eval ( n . string ) );
        self._reset(mark)
        if (
            (s := self.string())
        ):
            return Constant ( value = s . string );
        self._reset(mark)
        if (
            (self.expect('...'))
        ):
            return Constant ( value = ... );
        self._reset(mark)
        return None;

    @memoize
    def name_expr(self) -> Optional[Name]:
        # name_expr: NAME
        mark = self._mark()
        if (
            (n := self.name())
        ):
            return Name ( id = n . string );
        self._reset(mark)
        return None;

    @memoize
    def tuple(self) -> Optional[Tuple]:
        # tuple: '(' exprs? ')'
        mark = self._mark()
        if (
            (self.expect('('))
            and
            (a := self.exprs(),)
            and
            (self.expect(')'))
        ):
            return Tuple ( elts = a or [] );
        self._reset(mark)
        return None;

    @memoize
    def list(self) -> Optional[List]:
        # list: '[' exprs? ']'
        mark = self._mark()
        if (
            (self.expect('['))
            and
            (a := self.exprs(),)
            and
            (self.expect(']'))
        ):
            return List ( elts = a or [] );
        self._reset(mark)
        return None;

    @memoize
    def set(self) -> Optional[Set]:
        # set: '{' exprs? '}'
        mark = self._mark()
        if (
            (self.expect('{'))
            and
            (e := self.exprs(),)
            and
            (self.expect('}'))
        ):
            return Set ( elts = e or [] );
        self._reset(mark)
        return None;

    @memoize
    def dict(self) -> Optional[Dict]:
        # dict: '{' dict '}'
        mark = self._mark()
        if (
            (self.expect('{'))
            and
            (d := self.dict())
            and
            (self.expect('}'))
        ):
            return Dict ( keys = d [0] , values = d [1] );
        self._reset(mark)
        return None;

    @memoize
    def id(self) -> Optional[Capture [_Identifier] | WildcardId | _Identifier]:
        # id: capture_id | NAME | wildcard_id
        mark = self._mark()
        if (
            (capture_id := self.capture_id())
        ):
            return capture_id;
        self._reset(mark)
        if (
            (n := self.name())
        ):
            return n . string;
        self._reset(mark)
        if (
            (wildcard_id := self.wildcard_id())
        ):
            return wildcard_id;
        self._reset(mark)
        return None;

    @memoize
    def capture_id(self) -> Optional[Capture]:
        # capture_id: capture
        mark = self._mark()
        if (
            (c := self.capture())
        ):
            return Capture ( name = c ['name'] , pattern = WildcardId ( ) );
        self._reset(mark)
        return None;

    @memoize
    def wildcards0(self) -> Optional[Any]:
        # wildcards0: '~' '*'
        mark = self._mark()
        if (
            (literal := self.expect('~'))
            and
            (literal_1 := self.expect('*'))
        ):
            return [literal, literal_1];
        self._reset(mark)
        return None;

    @memoize
    def wildcards1(self) -> Optional[Any]:
        # wildcards1: '~' '+'
        mark = self._mark()
        if (
            (literal := self.expect('~'))
            and
            (literal_1 := self.expect('+'))
        ):
            return [literal, literal_1];
        self._reset(mark)
        return None;

    @memoize
    def wildcard(self) -> Optional[Wildcard]:
        # wildcard: '~'
        mark = self._mark()
        if (
            (self.expect('~'))
        ):
            return Wildcard ( );
        self._reset(mark)
        return None;

    @memoize
    def wildcard_id(self) -> Optional[WildcardId]:
        # wildcard_id: '`'
        mark = self._mark()
        if (
            (self.expect('`'))
        ):
            return WildcardId ( );
        self._reset(mark)
        return None;

    @memoize
    def capture(self) -> Optional[dict [str , str | int]]:
        # capture: '$' NAME | '$' NUMBER
        mark = self._mark()
        if (
            (self.expect('$'))
            and
            (n := self.name())
        ):
            return {'name' : n . string};
        self._reset(mark)
        if (
            (self.expect('$'))
            and
            (n := self.number())
        ):
            return {'name' : int ( n . string )};
        self._reset(mark)
        return None;

    @memoize
    def capture_pattern(self) -> Optional[Capture [ASTPattern [expr]]]:
        # capture_pattern: capture '{' expr '}'
        mark = self._mark()
        if (
            (c := self.capture())
            and
            (self.expect('{'))
            and
            (pattern := self.expr())
            and
            (self.expect('}'))
        ):
            return Capture ( name = c ['name'] , pattern = pattern );
        self._reset(mark)
        return None;

    @memoize
    def _tmp_1(self) -> Optional[Any]:
        # _tmp_1: '->' expression
        mark = self._mark()
        if (
            (self.expect('->'))
            and
            (z := self.expression())
        ):
            return z;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_2(self) -> Optional[Any]:
        # _tmp_2: '=' ellipsis?
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (opt := self.ellipsis(),)
        ):
            return [literal, opt];
        self._reset(mark)
        return None;

    @memoize
    def _loop0_4(self) -> Any:
        # _loop0_4: '\n' decorator
        mark = self._mark()
        children = []
        while (
            (self.expect('\n'))
            and
            (elem := self.decorator())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_3(self) -> Optional[Any]:
        # _gather_3: decorator _loop0_4
        mark = self._mark()
        if (
            (elem := self.decorator())
            is not None
            and
            (seq := self._loop0_4())
            is not None
        ):
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_5(self) -> list[ASTPattern [arg]]:
        # _loop0_5: param_no_default
        mark = self._mark()
        children = []
        while (
            (param_no_default := self.param_no_default())
        ):
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_6(self) -> list[NameDefaultPair]:
        # _loop0_6: param_with_default
        mark = self._mark()
        children = []
        while (
            (param_with_default := self.param_with_default())
        ):
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_7(self) -> list[NameDefaultPair]:
        # _loop0_7: param_with_default
        mark = self._mark()
        children = []
        while (
            (param_with_default := self.param_with_default())
        ):
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_8(self) -> list[ASTPattern [arg]]:
        # _loop1_8: param_no_default
        mark = self._mark()
        children = []
        while (
            (param_no_default := self.param_no_default())
        ):
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_9(self) -> list[NameDefaultPair]:
        # _loop0_9: param_with_default
        mark = self._mark()
        children = []
        while (
            (param_with_default := self.param_with_default())
        ):
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_10(self) -> list[NameDefaultPair]:
        # _loop1_10: param_with_default
        mark = self._mark()
        children = []
        while (
            (param_with_default := self.param_with_default())
        ):
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_11(self) -> list[ASTPattern [arg]]:
        # _loop1_11: param_no_default
        mark = self._mark()
        children = []
        while (
            (param_no_default := self.param_no_default())
        ):
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_12(self) -> list[ASTPattern [arg]]:
        # _loop1_12: param_no_default
        mark = self._mark()
        children = []
        while (
            (param_no_default := self.param_no_default())
        ):
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_13(self) -> list[ASTPattern [arg]]:
        # _loop0_13: param_no_default
        mark = self._mark()
        children = []
        while (
            (param_no_default := self.param_no_default())
        ):
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_14(self) -> list[NameDefaultPair]:
        # _loop1_14: param_with_default
        mark = self._mark()
        children = []
        while (
            (param_with_default := self.param_with_default())
        ):
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_15(self) -> list[ASTPattern [arg]]:
        # _loop0_15: param_no_default
        mark = self._mark()
        children = []
        while (
            (param_no_default := self.param_no_default())
        ):
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_16(self) -> list[NameDefaultPair]:
        # _loop1_16: param_with_default
        mark = self._mark()
        children = []
        while (
            (param_with_default := self.param_with_default())
        ):
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_17(self) -> list[NameDefaultPair]:
        # _loop0_17: param_maybe_default
        mark = self._mark()
        children = []
        while (
            (param_maybe_default := self.param_maybe_default())
        ):
            children.append(param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_18(self) -> list[NameDefaultPair]:
        # _loop0_18: param_maybe_default
        mark = self._mark()
        children = []
        while (
            (param_maybe_default := self.param_maybe_default())
        ):
            children.append(param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_19(self) -> list[NameDefaultPair]:
        # _loop1_19: param_maybe_default
        mark = self._mark()
        children = []
        while (
            (param_maybe_default := self.param_maybe_default())
        ):
            children.append(param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_20(self) -> Optional[Any]:
        # _tmp_20: expr ','? ')'
        mark = self._mark()
        if (
            (expr := self.expr())
            and
            (opt := self.expect(','),)
            and
            (literal := self.expect(')'))
        ):
            return [expr, opt, literal];
        self._reset(mark)
        return None;

    @memoize
    def _tmp_21(self) -> Optional[Any]:
        # _tmp_21: expr ','? ')'
        mark = self._mark()
        if (
            (expr := self.expr())
            and
            (opt := self.expect(','),)
            and
            (literal := self.expect(')'))
        ):
            return [expr, opt, literal];
        self._reset(mark)
        return None;

    @memoize
    def _loop0_23(self) -> Any:
        # _loop0_23: ',' expr
        mark = self._mark()
        children = []
        while (
            (self.expect(','))
            and
            (elem := self.expr())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_22(self) -> Optional[Any]:
        # _gather_22: expr _loop0_23
        mark = self._mark()
        if (
            (elem := self.expr())
            is not None
            and
            (seq := self._loop0_23())
            is not None
        ):
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_25(self) -> Any:
        # _loop0_25: ',' star_named_expr
        mark = self._mark()
        children = []
        while (
            (self.expect(','))
            and
            (elem := self.star_named_expr())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_24(self) -> Optional[Any]:
        # _gather_24: star_named_expr _loop0_25
        mark = self._mark()
        if (
            (elem := self.star_named_expr())
            is not None
            and
            (seq := self._loop0_25())
            is not None
        ):
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop1_26(self) -> Any:
        # _loop1_26: ('or' conjunction)
        mark = self._mark()
        children = []
        while (
            (_tmp_33 := self._tmp_33())
        ):
            children.append(_tmp_33)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_27(self) -> Any:
        # _loop1_27: ('and' inversion)
        mark = self._mark()
        children = []
        while (
            (_tmp_34 := self._tmp_34())
        ):
            children.append(_tmp_34)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_28(self) -> list[dict]:
        # _loop1_28: compare_op_bitwise_or_pair
        mark = self._mark()
        children = []
        while (
            (compare_op_bitwise_or_pair := self.compare_op_bitwise_or_pair())
        ):
            children.append(compare_op_bitwise_or_pair)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_29(self) -> Optional[Any]:
        # _tmp_29: tuple | group | genexp
        mark = self._mark()
        if (
            (tuple := self.tuple())
        ):
            return tuple;
        self._reset(mark)
        if (
            (group := self.group())
        ):
            return group;
        self._reset(mark)
        if (
            (genexp := self.genexp())
        ):
            return genexp;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_30(self) -> Optional[Any]:
        # _tmp_30: list | listcomp
        mark = self._mark()
        if (
            (list := self.list())
        ):
            return list;
        self._reset(mark)
        if (
            (listcomp := self.listcomp())
        ):
            return listcomp;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_31(self) -> Optional[Any]:
        # _tmp_31: dict | set | dictcomp | setcomp
        mark = self._mark()
        if (
            (dict := self.dict())
        ):
            return dict;
        self._reset(mark)
        if (
            (set := self.set())
        ):
            return set;
        self._reset(mark)
        if (
            (dictcomp := self.dictcomp())
        ):
            return dictcomp;
        self._reset(mark)
        if (
            (setcomp := self.setcomp())
        ):
            return setcomp;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_32(self) -> Optional[Any]:
        # _tmp_32: yield_expr | named_expr
        mark = self._mark()
        if (
            (yield_expr := self.yield_expr())
        ):
            return yield_expr;
        self._reset(mark)
        if (
            (named_expr := self.named_expr())
        ):
            return named_expr;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_33(self) -> Optional[Any]:
        # _tmp_33: 'or' conjunction
        mark = self._mark()
        if (
            (self.expect('or'))
            and
            (c := self.conjunction())
        ):
            return c;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_34(self) -> Optional[Any]:
        # _tmp_34: 'and' inversion
        mark = self._mark()
        if (
            (self.expect('and'))
            and
            (c := self.inversion())
        ):
            return c;
        self._reset(mark)
        return None;

    KEYWORDS = ('False', 'None', 'True', 'and', 'async', 'await', 'class', 'def', 'delete', 'else', 'for', 'from', 'if', 'in', 'is', 'not', 'or', 'return', 'todo', 'while', 'yield')
    SOFT_KEYWORDS = ()


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(DSLParser)
