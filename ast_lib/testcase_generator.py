#!/usr/bin/env python3.8
# @generated by pegen from C:\Users\kchon\OneDrive\Desktop\ast_lib\scripts\data\match.gram
# pyright: reportUnusedVariable=false, reportUnusedImport=false, reportIncompatibleMethodOverride=false, reportUnusedParameter=false
# ruff: noqa: F401, F841, E703, F405, F403, F634

from __future__ import annotations


import ast
import sys
import tokenize

from typing import Any, Optional, TYPE_CHECKING, cast

from rich import print
from pegen.parser import memoize, memoize_left_rec, logger
import string
import token
from dataclasses import dataclass
from typing import Literal, NamedTuple
from itertools import chain
from operator import itemgetter
from tokenize import TokenInfo
from hypothesis import strategies as st
from hypothesis import assume

from rich.traceback import install
from functools import reduce, wraps
from .nodes import *


def wrap_start(fn):
    @wraps(fn)
    def wrapper(self, *args, **kwargs):
        ret = fn(self, *args, **kwargs)
        return ret

    return wrapper


def wrap_stmt(fn):
    @wraps(fn)
    def wrapper(self, *args, **kwargs):
        lineno = self._tokenizer.peek().start[0]
        ret = fn(self, *args, **kwargs)
        return ret

    return wrapper


def _reduce_chain(p, s):
    def reducer(acc, suffix):
        if suffix["type"] == "Call":
            return Call(func=acc, args=suffix["args"])
        if suffix["type"] == "Attribute":
            return Attribute(value=acc, attr=suffix["attr"])
        if suffix["type"] == "Subscript":
            return Subscript(value=acc, slice=suffix["slice"])
        return acc

    return reduce(reducer, s, p)


def _make_dict(head, tail):
    return tuple(zip(*[head] + [(k, v) for _, k, __, v in tail]))


class TestcaseGeneratorBase:
    def name(self, max_depth: int) -> st.SearchStrategy[Testcase]:
        if max_depth <= 0:
            return st.nothing()

        return st.from_regex(
            r"[a-zA-Z_][a-zA-Z0-9_]*",
            fullmatch=True,
        ).map(lambda s: Testcase(CodeItem.from_str(s), fake_tokeninfo(s, token.NAME)))

    def number(self, max_depth: int) -> st.SearchStrategy[Testcase]:
        if max_depth <= 0:
            return st.nothing()

        # todo: negative numbers
        # @st.composite
        # def func(draw: st.DrawFn) -> tuple[list[CodeItem], TokenInfo]:
        #     s = draw(
        #         st.one_of(
        #             [
        #                 st.integers(min_value=0),
        #                 st.floats(min_value=0, allow_infinity=False),
        #             ]
        #         )
        #     )
        #     return CodeItem.from_str(str(s)), fake_tokeninfo(str(s), token.NUMBER)

        return st.one_of(
            st.integers(min_value=0),
            st.floats(min_value=0, allow_infinity=False),
        ).map(
            lambda x: Testcase(
                CodeItem.from_str(str(x)), fake_tokeninfo(str(x), token.NUMBER)
            )
        )

    def string(self, max_depth: int) -> st.SearchStrategy[Testcase]:
        if max_depth <= 0:
            return st.nothing()

        # @st.composite
        # def func(draw: st.DrawFn) -> tuple[list[CodeItem], TokenInfo]:
        #     s = draw(
        #         st.one_of(
        #             [
        #                 st.from_regex(
        #                     r'"[^"\n\s]*"', alphabet=string.printable, fullmatch=True
        #                 ),
        #                 st.from_regex(
        #                     r"'[^'\n\s]*'", alphabet=string.printable, fullmatch=True
        #                 ),
        #             ]
        #         )
        #     )
        #     return CodeItem.from_str(s), fake_tokeninfo(s, token.STRING)

        return st.one_of(
            st.from_regex(r'"[^"\n\s]*"', alphabet=string.printable, fullmatch=True),
            st.from_regex(r"'[^'\n\s]*'", alphabet=string.printable, fullmatch=True),
        ).map(lambda s: Testcase(CodeItem.from_str(s), fake_tokeninfo(s, token.STRING)))


@dataclass
class Testcase:
    code_items: list[CodeItem]
    node: ASTPattern[AST]  # pyright: ignore

    @classmethod
    def build(cls, *testcases: Testcase, reducer: Callable[..., ASTPattern[AST]]):  # pyright: ignore
        code_itemss = [testcase.code_items for testcase in testcases]
        code_items = CodeItem.merge(code_itemss)
        nodes = [testcase.node for testcase in testcases]
        return cls(code_items, reducer(*nodes))

    def __repr__(self) -> str:
        return "Testcase(" + "".join(item.value for item in self.code_items) + ")"


def transpose[T1, T2](tuples: list[tuple[T1, T2]]) -> tuple[list[T1], list[T2]]:
    return list(map(itemgetter(0), tuples)), list(map(itemgetter(1), tuples))


@st.composite
def check_lookahead[T](
    draw: st.DrawFn, strategy: st.SearchStrategy[tuple[list[list[CodeItem]], T]]
) -> tuple[list[CodeItem], T]:
    code_items, nodes = draw(strategy)
    code_items = list(chain(*code_items))
    new_code_items: list[CodeItem] = []
    breakpoint()
    for i in range(len(code_items) - 1):
        if code_items[i].type == "pos":
            if code_items[i + 1].type != "str":
                breakpoint()
            if code_items[i + 1].value != code_items[i].value:
                return draw(st.nothing())
        elif code_items[i].type == "neg":
            if code_items[i + 1].type != "str":
                breakpoint()
            if code_items[i + 1].value == code_items[i].value:
                return draw(st.nothing())

        new_code_items.append(code_items[i])
    new_code_items.append(code_items[-1])
    return new_code_items, nodes


class Never:
    pass


class CodeItem(NamedTuple):
    type: Literal["str", "neg", "pos"]
    value: str  # | CodeItem

    @staticmethod
    def merge(itemss: list[list[CodeItem]]) -> list[CodeItem]:
        if not itemss:
            return []
        first = itemss.pop(0)
        for items in itemss:
            for item in items:
                cur_last = first[-1]
                if cur_last.type == "pos":
                    if item.type == "str":
                        if item.value != cur_last.value:
                            # return draw(st.nothing())
                            raise Exception()
                    else:
                        breakpoint()
                if cur_last.type == "neg":
                    if item.type == "str":
                        if item.value == cur_last.value:
                            # return draw(st.nothing())
                            raise Exception()
                    else:
                        breakpoint()

                first.append(item)

        return first

    @classmethod
    def from_str(cls, s: str) -> list[CodeItem]:
        return [cls("str", s)]


@st.composite
def repeat_strategy[T](
    draw: st.DrawFn,
    arg: st.SearchStrategy[Testcase],
    min_size: int,
) -> tuple[list[CodeItem], list[T]]:
    # ss, vs =
    samples = draw(st.lists(arg, min_size=min_size))
    ss = [s.code_items for s in samples]
    vs = [s.node for s in samples]
    return CodeItem.merge(ss), vs


@st.composite
def gather_strategy[T0, T1](
    draw: st.DrawFn,
    call: st.SearchStrategy[Testcase],
    separator: st.SearchStrategy[Testcase],
) -> tuple[list[CodeItem], list[T0]]:
    # TODO: is this correct?
    calls = draw(st.lists(call, min_size=0))
    assume(len(calls) > 0)
    assert len(calls) > 0

    num_seps = len(calls) - 1
    seps = draw(st.lists(separator, min_size=num_seps, max_size=num_seps)) + [
        Testcase([], None)
    ]

    x = list(chain(*zip(calls, seps)))[:-1]
    ss = [s.code_items for s in x]
    vs = [v.node for v in x]
    return CodeItem.merge(ss), vs


def fake_tokeninfo(s: str, type: int) -> TokenInfo:
    if s in token.EXACT_TOKEN_TYPES:
        type = token.EXACT_TOKEN_TYPES[s]
    return TokenInfo(type=type, string=s, start=(0, 0), end=(0, len(s)), line="")


install()
debug_cnt = 0


# Keywords and soft keywords are listed at the end of the parser definition.
class TestcaseGenerator(TestcaseGeneratorBase):
    def start(self, max_depth: int) -> st.SearchStrategy[tuple[list[CodeItem], stmt]]:
        if max_depth <= 0:
            return st.nothing()
        # start: stmt
        choices: list[st.SearchStrategy[tuple[list[CodeItem], stmt]]] = []
        if (stmt := self.stmt(max_depth - 1),):

            def reducer(stmt):
                return stmt

            start_st = st.builds(Testcase.build, stmt, reducer=st.just(reducer))
            choices.append(start_st)
        return st.one_of(choices)

    def stmt(self, max_depth: int) -> st.SearchStrategy[tuple[list[CodeItem], stmt]]:
        if max_depth <= 0:
            return st.nothing()
        # stmt: function_def | async_function_def | class_def | return_stmt | delete_stmt | assign | ann_assign | for_stmt | async_for | while_stmt | if_stmt | expr_stmt
        choices: list[st.SearchStrategy[tuple[list[CodeItem], stmt]]] = []
        if (function_def := self.function_def(max_depth - 1),):

            def reducer(function_def):
                return function_def

            stmt_st = st.builds(Testcase.build, function_def, reducer=st.just(reducer))
            choices.append(stmt_st)
        if (async_function_def := self.async_function_def(max_depth - 1),):

            def reducer(async_function_def):
                return async_function_def

            stmt_st = st.builds(
                Testcase.build, async_function_def, reducer=st.just(reducer)
            )
            choices.append(stmt_st)
        if (class_def := self.class_def(max_depth - 1),):

            def reducer(class_def):
                return class_def

            stmt_st = st.builds(Testcase.build, class_def, reducer=st.just(reducer))
            choices.append(stmt_st)
        if (return_stmt := self.return_stmt(max_depth - 1),):

            def reducer(return_stmt):
                return return_stmt

            stmt_st = st.builds(Testcase.build, return_stmt, reducer=st.just(reducer))
            choices.append(stmt_st)
        if (delete_stmt := self.delete_stmt(max_depth - 1),):

            def reducer(delete_stmt):
                return delete_stmt

            stmt_st = st.builds(Testcase.build, delete_stmt, reducer=st.just(reducer))
            choices.append(stmt_st)
        if (assign := self.assign(max_depth - 1),):

            def reducer(assign):
                return assign

            stmt_st = st.builds(Testcase.build, assign, reducer=st.just(reducer))
            choices.append(stmt_st)
        if (ann_assign := self.ann_assign(max_depth - 1),):

            def reducer(ann_assign):
                return ann_assign

            stmt_st = st.builds(Testcase.build, ann_assign, reducer=st.just(reducer))
            choices.append(stmt_st)
        if (for_stmt := self.for_stmt(max_depth - 1),):

            def reducer(for_stmt):
                return for_stmt

            stmt_st = st.builds(Testcase.build, for_stmt, reducer=st.just(reducer))
            choices.append(stmt_st)
        if (async_for := self.async_for(max_depth - 1),):

            def reducer(async_for):
                return async_for

            stmt_st = st.builds(Testcase.build, async_for, reducer=st.just(reducer))
            choices.append(stmt_st)
        if (while_stmt := self.while_stmt(max_depth - 1),):

            def reducer(while_stmt):
                return while_stmt

            stmt_st = st.builds(Testcase.build, while_stmt, reducer=st.just(reducer))
            choices.append(stmt_st)
        if (if_stmt := self.if_stmt(max_depth - 1),):

            def reducer(if_stmt):
                return if_stmt

            stmt_st = st.builds(Testcase.build, if_stmt, reducer=st.just(reducer))
            choices.append(stmt_st)
        if (expr_stmt := self.expr_stmt(max_depth - 1),):

            def reducer(expr_stmt):
                return expr_stmt

            stmt_st = st.builds(Testcase.build, expr_stmt, reducer=st.just(reducer))
            choices.append(stmt_st)
        return st.one_of(choices)

    def function_def(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], FunctionDef]]:
        if max_depth <= 0:
            return st.nothing()
        # function_def: decorators? 'def' id '(' args ')' ellipsis?
        choices: list[st.SearchStrategy[tuple[list[CodeItem], FunctionDef]]] = []
        if (
            (
                d := st.one_of(
                    st.just(Testcase(CodeItem.from_str(""), None)),
                    self.decorators(max_depth - 1),
                ),
            )
            and (
                literal := st.just(
                    Testcase(
                        CodeItem.from_str("def"), fake_tokeninfo("def", token.STRING)
                    )
                ),
            )
            and (n := self.id(max_depth - 1),)
            and (
                literal_1 := st.just(
                    Testcase(CodeItem.from_str("("), fake_tokeninfo("(", token.STRING))
                ),
            )
            and (a := self.args(max_depth - 1),)
            and (
                literal_2 := st.just(
                    Testcase(CodeItem.from_str(")"), fake_tokeninfo(")", token.STRING))
                ),
            )
            and (
                opt := st.one_of(
                    st.just(Testcase(CodeItem.from_str(""), None)),
                    self.ellipsis(max_depth - 1),
                ),
            )
        ):

            def reducer(d, literal, n, literal_1, a, literal_2, opt):
                return FunctionDef(name=n, decorator_list=d or [])

            function_def_st = st.builds(
                Testcase.build,
                d,
                literal,
                n,
                literal_1,
                a,
                literal_2,
                opt,
                reducer=st.just(reducer),
            )
            choices.append(function_def_st)
        return st.one_of(choices)

    def async_function_def(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], AsyncFunctionDef]]:
        if max_depth <= 0:
            return st.nothing()
        # async_function_def: decorators? 'async' 'def' id '(' args ')' ellipsis?
        choices: list[st.SearchStrategy[tuple[list[CodeItem], AsyncFunctionDef]]] = []
        if (
            (
                d := st.one_of(
                    st.just(Testcase(CodeItem.from_str(""), None)),
                    self.decorators(max_depth - 1),
                ),
            )
            and (
                literal := st.just(
                    Testcase(
                        CodeItem.from_str("async"),
                        fake_tokeninfo("async", token.STRING),
                    )
                ),
            )
            and (
                literal_1 := st.just(
                    Testcase(
                        CodeItem.from_str("def"), fake_tokeninfo("def", token.STRING)
                    )
                ),
            )
            and (n := self.id(max_depth - 1),)
            and (
                literal_2 := st.just(
                    Testcase(CodeItem.from_str("("), fake_tokeninfo("(", token.STRING))
                ),
            )
            and (a := self.args(max_depth - 1),)
            and (
                literal_3 := st.just(
                    Testcase(CodeItem.from_str(")"), fake_tokeninfo(")", token.STRING))
                ),
            )
            and (
                opt := st.one_of(
                    st.just(Testcase(CodeItem.from_str(""), None)),
                    self.ellipsis(max_depth - 1),
                ),
            )
        ):

            def reducer(d, literal, literal_1, n, literal_2, a, literal_3, opt):
                return AsyncFunctionDef(name=n, decorator_list=d or [])

            async_function_def_st = st.builds(
                Testcase.build,
                d,
                literal,
                literal_1,
                n,
                literal_2,
                a,
                literal_3,
                opt,
                reducer=st.just(reducer),
            )
            choices.append(async_function_def_st)
        return st.one_of(choices)

    def class_def(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], ClassDef]]:
        if max_depth <= 0:
            return st.nothing()
        # class_def: decorators? 'class' id class_bases? ellipsis?
        choices: list[st.SearchStrategy[tuple[list[CodeItem], ClassDef]]] = []
        if (
            (
                d := st.one_of(
                    st.just(Testcase(CodeItem.from_str(""), None)),
                    self.decorators(max_depth - 1),
                ),
            )
            and (
                literal := st.just(
                    Testcase(
                        CodeItem.from_str("class"),
                        fake_tokeninfo("class", token.STRING),
                    )
                ),
            )
            and (n := self.id(max_depth - 1),)
            and (
                bases := st.one_of(
                    st.just(Testcase(CodeItem.from_str(""), None)),
                    self.class_bases(max_depth - 1),
                ),
            )
            and (
                opt := st.one_of(
                    st.just(Testcase(CodeItem.from_str(""), None)),
                    self.ellipsis(max_depth - 1),
                ),
            )
        ):

            def reducer(d, literal, n, bases, opt):
                return ClassDef(name=n, bases=bases or [], decorator_list=d or [])

            class_def_st = st.builds(
                Testcase.build, d, literal, n, bases, opt, reducer=st.just(reducer)
            )
            choices.append(class_def_st)
        return st.one_of(choices)

    def return_stmt(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], Return]]:
        if max_depth <= 0:
            return st.nothing()
        # return_stmt: 'return' expr
        choices: list[st.SearchStrategy[tuple[list[CodeItem], Return]]] = []
        if (
            literal := st.just(
                Testcase(
                    CodeItem.from_str("return"), fake_tokeninfo("return", token.STRING)
                )
            ),
        ) and (e := self.expr(max_depth - 1),):

            def reducer(literal, e):
                return Return(value=e)

            return_stmt_st = st.builds(
                Testcase.build, literal, e, reducer=st.just(reducer)
            )
            choices.append(return_stmt_st)
        return st.one_of(choices)

    def delete_stmt(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], Delete]]:
        if max_depth <= 0:
            return st.nothing()
        # delete_stmt: 'delete' exprs
        choices: list[st.SearchStrategy[tuple[list[CodeItem], Delete]]] = []
        if (
            literal := st.just(
                Testcase(
                    CodeItem.from_str("delete"), fake_tokeninfo("delete", token.STRING)
                )
            ),
        ) and (e := self.exprs(max_depth - 1),):

            def reducer(literal, e):
                return Delete(targets=e)

            delete_stmt_st = st.builds(
                Testcase.build, literal, e, reducer=st.just(reducer)
            )
            choices.append(delete_stmt_st)
        return st.one_of(choices)

    def assign(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], Assign]]:
        if max_depth <= 0:
            return st.nothing()
        # assign: exprs '=' expr
        choices: list[st.SearchStrategy[tuple[list[CodeItem], Assign]]] = []
        if (
            (targets := self.exprs(max_depth - 1),)
            and (
                literal := st.just(
                    Testcase(CodeItem.from_str("="), fake_tokeninfo("=", token.STRING))
                ),
            )
            and (value := self.expr(max_depth - 1),)
        ):

            def reducer(targets, literal, value):
                return Assign(targets=targets, value=value)

            assign_st = st.builds(
                Testcase.build, targets, literal, value, reducer=st.just(reducer)
            )
            choices.append(assign_st)
        return st.one_of(choices)

    def ann_assign(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], AnnAssign]]:
        if max_depth <= 0:
            return st.nothing()
        # ann_assign: expr ':' expr '=' expr
        choices: list[st.SearchStrategy[tuple[list[CodeItem], AnnAssign]]] = []
        if (
            (target := self.expr(max_depth - 1),)
            and (
                literal := st.just(
                    Testcase(CodeItem.from_str(":"), fake_tokeninfo(":", token.STRING))
                ),
            )
            and (ann := self.expr(max_depth - 1),)
            and (
                literal_1 := st.just(
                    Testcase(CodeItem.from_str("="), fake_tokeninfo("=", token.STRING))
                ),
            )
            and (value := self.expr(max_depth - 1),)
        ):

            def reducer(target, literal, ann, literal_1, value):
                return AnnAssign(target=target, annotation=ann, value=value)

            ann_assign_st = st.builds(
                Testcase.build,
                target,
                literal,
                ann,
                literal_1,
                value,
                reducer=st.just(reducer),
            )
            choices.append(ann_assign_st)
        return st.one_of(choices)

    def for_stmt(self, max_depth: int) -> st.SearchStrategy[tuple[list[CodeItem], For]]:
        if max_depth <= 0:
            return st.nothing()
        # for_stmt: 'for' expr 'in' expr ellipsis?
        choices: list[st.SearchStrategy[tuple[list[CodeItem], For]]] = []
        if (
            (
                literal := st.just(
                    Testcase(
                        CodeItem.from_str("for"), fake_tokeninfo("for", token.STRING)
                    )
                ),
            )
            and (target := self.expr(max_depth - 1),)
            and (
                literal_1 := st.just(
                    Testcase(
                        CodeItem.from_str("in"), fake_tokeninfo("in", token.STRING)
                    )
                ),
            )
            and (iter := self.expr(max_depth - 1),)
            and (
                opt := st.one_of(
                    st.just(Testcase(CodeItem.from_str(""), None)),
                    self.ellipsis(max_depth - 1),
                ),
            )
        ):

            def reducer(literal, target, literal_1, iter, opt):
                return For(target=target, iter=iter)

            for_stmt_st = st.builds(
                Testcase.build,
                literal,
                target,
                literal_1,
                iter,
                opt,
                reducer=st.just(reducer),
            )
            choices.append(for_stmt_st)
        return st.one_of(choices)

    def async_for(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], AsyncFor]]:
        if max_depth <= 0:
            return st.nothing()
        # async_for: 'async' 'for' expr 'in' expr ellipsis?
        choices: list[st.SearchStrategy[tuple[list[CodeItem], AsyncFor]]] = []
        if (
            (
                literal := st.just(
                    Testcase(
                        CodeItem.from_str("async"),
                        fake_tokeninfo("async", token.STRING),
                    )
                ),
            )
            and (
                literal_1 := st.just(
                    Testcase(
                        CodeItem.from_str("for"), fake_tokeninfo("for", token.STRING)
                    )
                ),
            )
            and (target := self.expr(max_depth - 1),)
            and (
                literal_2 := st.just(
                    Testcase(
                        CodeItem.from_str("in"), fake_tokeninfo("in", token.STRING)
                    )
                ),
            )
            and (iter := self.expr(max_depth - 1),)
            and (
                opt := st.one_of(
                    st.just(Testcase(CodeItem.from_str(""), None)),
                    self.ellipsis(max_depth - 1),
                ),
            )
        ):

            def reducer(literal, literal_1, target, literal_2, iter, opt):
                return AsyncFor(target=target, iter=iter)

            async_for_st = st.builds(
                Testcase.build,
                literal,
                literal_1,
                target,
                literal_2,
                iter,
                opt,
                reducer=st.just(reducer),
            )
            choices.append(async_for_st)
        return st.one_of(choices)

    def while_stmt(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], While]]:
        if max_depth <= 0:
            return st.nothing()
        # while_stmt: 'while' expr ellipsis?
        choices: list[st.SearchStrategy[tuple[list[CodeItem], While]]] = []
        if (
            (
                literal := st.just(
                    Testcase(
                        CodeItem.from_str("while"),
                        fake_tokeninfo("while", token.STRING),
                    )
                ),
            )
            and (test := self.expr(max_depth - 1),)
            and (
                opt := st.one_of(
                    st.just(Testcase(CodeItem.from_str(""), None)),
                    self.ellipsis(max_depth - 1),
                ),
            )
        ):

            def reducer(literal, test, opt):
                return While(test=test)

            while_stmt_st = st.builds(
                Testcase.build, literal, test, opt, reducer=st.just(reducer)
            )
            choices.append(while_stmt_st)
        return st.one_of(choices)

    def if_stmt(self, max_depth: int) -> st.SearchStrategy[tuple[list[CodeItem], If]]:
        if max_depth <= 0:
            return st.nothing()
        # if_stmt: 'if' expr [('=' ellipsis?)]
        choices: list[st.SearchStrategy[tuple[list[CodeItem], If]]] = []
        if (
            (
                literal := st.just(
                    Testcase(
                        CodeItem.from_str("if"), fake_tokeninfo("if", token.STRING)
                    )
                ),
            )
            and (test := self.expr(max_depth - 1),)
            and (
                opt := st.one_of(
                    st.just(Testcase(CodeItem.from_str(""), None)),
                    self._tmp_1(max_depth - 1),
                ),
            )
        ):

            def reducer(literal, test, opt):
                return If(test=test)

            if_stmt_st = st.builds(
                Testcase.build, literal, test, opt, reducer=st.just(reducer)
            )
            choices.append(if_stmt_st)
        return st.one_of(choices)

    def expr_stmt(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], Expr]]:
        if max_depth <= 0:
            return st.nothing()
        # expr_stmt: expr
        choices: list[st.SearchStrategy[tuple[list[CodeItem], Expr]]] = []
        if (e := self.expr(max_depth - 1),):

            def reducer(e):
                return Expr(value=e)

            expr_stmt_st = st.builds(Testcase.build, e, reducer=st.just(reducer))
            choices.append(expr_stmt_st)
        return st.one_of(choices)

    def decorators(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], list[ASTPattern[expr]]]]:
        if max_depth <= 0:
            return st.nothing()
        # decorators: '\n'.decorator+
        choices: list[
            st.SearchStrategy[tuple[list[CodeItem], list[ASTPattern[expr]]]]
        ] = []
        if (
            gather := gather_strategy(
                self.decorator(max_depth - 1),
                st.just(
                    Testcase(
                        CodeItem.from_str("\n"), fake_tokeninfo("\n", token.STRING)
                    )
                ),
            ),
        ):

            def reducer(gather):
                return gather

            decorators_st = st.builds(Testcase.build, gather, reducer=st.just(reducer))
            choices.append(decorators_st)
        return st.one_of(choices)

    def decorator(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]:
        if max_depth <= 0:
            return st.nothing()
        # decorator: '@' expr
        choices: list[st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]] = []
        if (
            literal := st.just(
                Testcase(CodeItem.from_str("@"), fake_tokeninfo("@", token.STRING))
            ),
        ) and (e := self.expr(max_depth - 1),):

            def reducer(literal, e):
                return e

            decorator_st = st.builds(
                Testcase.build, literal, e, reducer=st.just(reducer)
            )
            choices.append(decorator_st)
        return st.one_of(choices)

    def class_bases(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], list[ASTPattern[expr]]]]:
        if max_depth <= 0:
            return st.nothing()
        # class_bases: '(' exprs ')'
        choices: list[
            st.SearchStrategy[tuple[list[CodeItem], list[ASTPattern[expr]]]]
        ] = []
        if (
            (
                literal := st.just(
                    Testcase(CodeItem.from_str("("), fake_tokeninfo("(", token.STRING))
                ),
            )
            and (e := self.exprs(max_depth - 1),)
            and (
                literal_1 := st.just(
                    Testcase(CodeItem.from_str(")"), fake_tokeninfo(")", token.STRING))
                ),
            )
        ):

            def reducer(literal, e, literal_1):
                return e

            class_bases_st = st.builds(
                Testcase.build, literal, e, literal_1, reducer=st.just(reducer)
            )
            choices.append(class_bases_st)
        return st.one_of(choices)

    def exprs(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], list[ASTPattern[expr]]]]:
        if max_depth <= 0:
            return st.nothing()
        # exprs: ','.expr+ ','?
        choices: list[
            st.SearchStrategy[tuple[list[CodeItem], list[ASTPattern[expr]]]]
        ] = []
        if (
            e := gather_strategy(
                self.expr(max_depth - 1),
                st.just(
                    Testcase(CodeItem.from_str(","), fake_tokeninfo(",", token.STRING))
                ),
            ),
        ) and (
            opt := st.one_of(
                st.just(Testcase(CodeItem.from_str(""), None)),
                st.just(
                    Testcase(CodeItem.from_str(","), fake_tokeninfo(",", token.STRING))
                ),
            ),
        ):

            def reducer(e, opt):
                return e

            exprs_st = st.builds(Testcase.build, e, opt, reducer=st.just(reducer))
            choices.append(exprs_st)
        return st.one_of(choices)

    def args(self, max_depth: int) -> st.SearchStrategy[tuple[list[CodeItem], Any]]:
        if max_depth <= 0:
            return st.nothing()
        # args: 'TODO'
        choices: list[st.SearchStrategy[tuple[list[CodeItem], Any]]] = []
        if (
            literal := st.just(
                Testcase(
                    CodeItem.from_str("TODO"), fake_tokeninfo("TODO", token.STRING)
                )
            ),
        ):

            def reducer(literal):
                return literal

            args_st = st.builds(Testcase.build, literal, reducer=st.just(reducer))
            choices.append(args_st)
        return st.one_of(choices)

    def expr(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]:
        if max_depth <= 0:
            return st.nothing()
        # expr: disjunction
        choices: list[st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]] = []
        if (disjunction := self.disjunction(max_depth - 1),):

            def reducer(disjunction):
                return disjunction

            expr_st = st.builds(Testcase.build, disjunction, reducer=st.just(reducer))
            choices.append(expr_st)
        return st.one_of(choices)

    def disjunction(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]:
        if max_depth <= 0:
            return st.nothing()
        # disjunction: conjunction (('or' conjunction))+ | conjunction
        choices: list[st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]] = []
        if (a := self.conjunction(max_depth - 1),) and (
            b := repeat_strategy(self._tmp_2(max_depth - 1), min_size=1),
        ):

            def reducer(a, b):
                return BoolOp(op=Or(), values=[a, *b])

            disjunction_st = st.builds(Testcase.build, a, b, reducer=st.just(reducer))
            choices.append(disjunction_st)
        if (conjunction := self.conjunction(max_depth - 1),):

            def reducer(conjunction):
                return conjunction

            disjunction_st = st.builds(
                Testcase.build, conjunction, reducer=st.just(reducer)
            )
            choices.append(disjunction_st)
        return st.one_of(choices)

    def conjunction(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]:
        if max_depth <= 0:
            return st.nothing()
        # conjunction: inversion (('and' inversion))+ | inversion
        choices: list[st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]] = []
        if (a := self.inversion(max_depth - 1),) and (
            b := repeat_strategy(self._tmp_3(max_depth - 1), min_size=1),
        ):

            def reducer(a, b):
                return BoolOp(op=And(), values=[a, *b])

            conjunction_st = st.builds(Testcase.build, a, b, reducer=st.just(reducer))
            choices.append(conjunction_st)
        if (inversion := self.inversion(max_depth - 1),):

            def reducer(inversion):
                return inversion

            conjunction_st = st.builds(
                Testcase.build, inversion, reducer=st.just(reducer)
            )
            choices.append(conjunction_st)
        return st.one_of(choices)

    def inversion(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]:
        if max_depth <= 0:
            return st.nothing()
        # inversion: 'not' inversion | comparison
        choices: list[st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]] = []
        if (
            literal := st.just(
                Testcase(CodeItem.from_str("not"), fake_tokeninfo("not", token.STRING))
            ),
        ) and (a := self.inversion(max_depth - 1),):

            def reducer(literal, a):
                return UnaryOp(op=Not(), operand=a)

            inversion_st = st.builds(
                Testcase.build, literal, a, reducer=st.just(reducer)
            )
            choices.append(inversion_st)
        if (comparison := self.comparison(max_depth - 1),):

            def reducer(comparison):
                return comparison

            inversion_st = st.builds(
                Testcase.build, comparison, reducer=st.just(reducer)
            )
            choices.append(inversion_st)
        return st.one_of(choices)

    def comparison(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]:
        if max_depth <= 0:
            return st.nothing()
        # comparison: bitwise_or compare_op_bitwise_or_pair+ | bitwise_or
        choices: list[st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]] = []
        if (a := self.bitwise_or(max_depth - 1),) and (
            b := repeat_strategy(
                self.compare_op_bitwise_or_pair(max_depth - 1), min_size=1
            ),
        ):

            def reducer(a, b):
                return Compare(
                    left=a,
                    ops=[pair["op"] for pair in b],
                    comparators=[pair["comparator"] for pair in b],
                )

            comparison_st = st.builds(Testcase.build, a, b, reducer=st.just(reducer))
            choices.append(comparison_st)
        if (bitwise_or := self.bitwise_or(max_depth - 1),):

            def reducer(bitwise_or):
                return bitwise_or

            comparison_st = st.builds(
                Testcase.build, bitwise_or, reducer=st.just(reducer)
            )
            choices.append(comparison_st)
        return st.one_of(choices)

    def compare_op_bitwise_or_pair(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], dict]]:
        if max_depth <= 0:
            return st.nothing()
        # compare_op_bitwise_or_pair: '==' bitwise_or | '!=' bitwise_or | '<=' bitwise_or | '<' bitwise_or | '>=' bitwise_or | '>' bitwise_or | 'not' 'in' bitwise_or | 'in' bitwise_or | 'is' 'not' bitwise_or | 'is' bitwise_or
        choices: list[st.SearchStrategy[tuple[list[CodeItem], dict]]] = []
        if (
            literal := st.just(
                Testcase(CodeItem.from_str("=="), fake_tokeninfo("==", token.STRING))
            ),
        ) and (b := self.bitwise_or(max_depth - 1),):

            def reducer(literal, b):
                return {"op": Eq(), "comparator": b}

            compare_op_bitwise_or_pair_st = st.builds(
                Testcase.build, literal, b, reducer=st.just(reducer)
            )
            choices.append(compare_op_bitwise_or_pair_st)
        if (
            literal := st.just(
                Testcase(CodeItem.from_str("!="), fake_tokeninfo("!=", token.STRING))
            ),
        ) and (b := self.bitwise_or(max_depth - 1),):

            def reducer(literal, b):
                return {"op": NotEq(), "comparator": b}

            compare_op_bitwise_or_pair_st = st.builds(
                Testcase.build, literal, b, reducer=st.just(reducer)
            )
            choices.append(compare_op_bitwise_or_pair_st)
        if (
            literal := st.just(
                Testcase(CodeItem.from_str("<="), fake_tokeninfo("<=", token.STRING))
            ),
        ) and (b := self.bitwise_or(max_depth - 1),):

            def reducer(literal, b):
                return {"op": LtE(), "comparator": b}

            compare_op_bitwise_or_pair_st = st.builds(
                Testcase.build, literal, b, reducer=st.just(reducer)
            )
            choices.append(compare_op_bitwise_or_pair_st)
        if (
            literal := st.just(
                Testcase(CodeItem.from_str("<"), fake_tokeninfo("<", token.STRING))
            ),
        ) and (b := self.bitwise_or(max_depth - 1),):

            def reducer(literal, b):
                return {"op": Lt(), "comparator": b}

            compare_op_bitwise_or_pair_st = st.builds(
                Testcase.build, literal, b, reducer=st.just(reducer)
            )
            choices.append(compare_op_bitwise_or_pair_st)
        if (
            literal := st.just(
                Testcase(CodeItem.from_str(">="), fake_tokeninfo(">=", token.STRING))
            ),
        ) and (b := self.bitwise_or(max_depth - 1),):

            def reducer(literal, b):
                return {"op": GtE(), "comparator": b}

            compare_op_bitwise_or_pair_st = st.builds(
                Testcase.build, literal, b, reducer=st.just(reducer)
            )
            choices.append(compare_op_bitwise_or_pair_st)
        if (
            literal := st.just(
                Testcase(CodeItem.from_str(">"), fake_tokeninfo(">", token.STRING))
            ),
        ) and (b := self.bitwise_or(max_depth - 1),):

            def reducer(literal, b):
                return {"op": Gt(), "comparator": b}

            compare_op_bitwise_or_pair_st = st.builds(
                Testcase.build, literal, b, reducer=st.just(reducer)
            )
            choices.append(compare_op_bitwise_or_pair_st)
        if (
            (
                literal := st.just(
                    Testcase(
                        CodeItem.from_str("not"), fake_tokeninfo("not", token.STRING)
                    )
                ),
            )
            and (
                literal_1 := st.just(
                    Testcase(
                        CodeItem.from_str("in"), fake_tokeninfo("in", token.STRING)
                    )
                ),
            )
            and (b := self.bitwise_or(max_depth - 1),)
        ):

            def reducer(literal, literal_1, b):
                return {"op": NotIn(), "comparator": b}

            compare_op_bitwise_or_pair_st = st.builds(
                Testcase.build, literal, literal_1, b, reducer=st.just(reducer)
            )
            choices.append(compare_op_bitwise_or_pair_st)
        if (
            literal := st.just(
                Testcase(CodeItem.from_str("in"), fake_tokeninfo("in", token.STRING))
            ),
        ) and (b := self.bitwise_or(max_depth - 1),):

            def reducer(literal, b):
                return {"op": In(), "comparator": b}

            compare_op_bitwise_or_pair_st = st.builds(
                Testcase.build, literal, b, reducer=st.just(reducer)
            )
            choices.append(compare_op_bitwise_or_pair_st)
        if (
            (
                literal := st.just(
                    Testcase(
                        CodeItem.from_str("is"), fake_tokeninfo("is", token.STRING)
                    )
                ),
            )
            and (
                literal_1 := st.just(
                    Testcase(
                        CodeItem.from_str("not"), fake_tokeninfo("not", token.STRING)
                    )
                ),
            )
            and (b := self.bitwise_or(max_depth - 1),)
        ):

            def reducer(literal, literal_1, b):
                return {"op": IsNot(), "comparator": b}

            compare_op_bitwise_or_pair_st = st.builds(
                Testcase.build, literal, literal_1, b, reducer=st.just(reducer)
            )
            choices.append(compare_op_bitwise_or_pair_st)
        if (
            literal := st.just(
                Testcase(CodeItem.from_str("is"), fake_tokeninfo("is", token.STRING))
            ),
        ) and (b := self.bitwise_or(max_depth - 1),):

            def reducer(literal, b):
                return {"op": Is(), "comparator": b}

            compare_op_bitwise_or_pair_st = st.builds(
                Testcase.build, literal, b, reducer=st.just(reducer)
            )
            choices.append(compare_op_bitwise_or_pair_st)
        return st.one_of(choices)

    def bitwise_or(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]:
        if max_depth <= 0:
            return st.nothing()
        # bitwise_or: bitwise_or '|' bitwise_xor | bitwise_xor
        choices: list[st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]] = []
        if (
            (a := self.bitwise_or(max_depth - 1),)
            and (
                literal := st.just(
                    Testcase(CodeItem.from_str("|"), fake_tokeninfo("|", token.STRING))
                ),
            )
            and (b := self.bitwise_xor(max_depth - 1),)
        ):

            def reducer(a, literal, b):
                return BinOp(left=a, op=BitOr(), right=b)

            bitwise_or_st = st.builds(
                Testcase.build, a, literal, b, reducer=st.just(reducer)
            )
            choices.append(bitwise_or_st)
        if (bitwise_xor := self.bitwise_xor(max_depth - 1),):

            def reducer(bitwise_xor):
                return bitwise_xor

            bitwise_or_st = st.builds(
                Testcase.build, bitwise_xor, reducer=st.just(reducer)
            )
            choices.append(bitwise_or_st)
        return st.one_of(choices)

    def bitwise_xor(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]:
        if max_depth <= 0:
            return st.nothing()
        # bitwise_xor: bitwise_xor '^' bitwise_and | bitwise_and
        choices: list[st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]] = []
        if (
            (a := self.bitwise_xor(max_depth - 1),)
            and (
                literal := st.just(
                    Testcase(CodeItem.from_str("^"), fake_tokeninfo("^", token.STRING))
                ),
            )
            and (b := self.bitwise_and(max_depth - 1),)
        ):

            def reducer(a, literal, b):
                return BinOp(left=a, op=BitXor(), right=b)

            bitwise_xor_st = st.builds(
                Testcase.build, a, literal, b, reducer=st.just(reducer)
            )
            choices.append(bitwise_xor_st)
        if (bitwise_and := self.bitwise_and(max_depth - 1),):

            def reducer(bitwise_and):
                return bitwise_and

            bitwise_xor_st = st.builds(
                Testcase.build, bitwise_and, reducer=st.just(reducer)
            )
            choices.append(bitwise_xor_st)
        return st.one_of(choices)

    def bitwise_and(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]:
        if max_depth <= 0:
            return st.nothing()
        # bitwise_and: bitwise_and '&' shift_expr | shift_expr
        choices: list[st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]] = []
        if (
            (a := self.bitwise_and(max_depth - 1),)
            and (
                literal := st.just(
                    Testcase(CodeItem.from_str("&"), fake_tokeninfo("&", token.STRING))
                ),
            )
            and (b := self.shift_expr(max_depth - 1),)
        ):

            def reducer(a, literal, b):
                return BinOp(left=a, op=BitAnd(), right=b)

            bitwise_and_st = st.builds(
                Testcase.build, a, literal, b, reducer=st.just(reducer)
            )
            choices.append(bitwise_and_st)
        if (shift_expr := self.shift_expr(max_depth - 1),):

            def reducer(shift_expr):
                return shift_expr

            bitwise_and_st = st.builds(
                Testcase.build, shift_expr, reducer=st.just(reducer)
            )
            choices.append(bitwise_and_st)
        return st.one_of(choices)

    def shift_expr(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]:
        if max_depth <= 0:
            return st.nothing()
        # shift_expr: shift_expr '<<' sum | shift_expr '>>' sum | sum
        choices: list[st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]] = []
        if (
            (a := self.shift_expr(max_depth - 1),)
            and (
                literal := st.just(
                    Testcase(
                        CodeItem.from_str("<<"), fake_tokeninfo("<<", token.STRING)
                    )
                ),
            )
            and (b := self.sum(max_depth - 1),)
        ):

            def reducer(a, literal, b):
                return BinOp(left=a, op=LShift(), right=b)

            shift_expr_st = st.builds(
                Testcase.build, a, literal, b, reducer=st.just(reducer)
            )
            choices.append(shift_expr_st)
        if (
            (a := self.shift_expr(max_depth - 1),)
            and (
                literal := st.just(
                    Testcase(
                        CodeItem.from_str(">>"), fake_tokeninfo(">>", token.STRING)
                    )
                ),
            )
            and (b := self.sum(max_depth - 1),)
        ):

            def reducer(a, literal, b):
                return BinOp(left=a, op=RShift(), right=b)

            shift_expr_st = st.builds(
                Testcase.build, a, literal, b, reducer=st.just(reducer)
            )
            choices.append(shift_expr_st)
        if (sum := self.sum(max_depth - 1),):

            def reducer(sum):
                return sum

            shift_expr_st = st.builds(Testcase.build, sum, reducer=st.just(reducer))
            choices.append(shift_expr_st)
        return st.one_of(choices)

    def sum(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]:
        if max_depth <= 0:
            return st.nothing()
        # sum: sum '+' term | sum '-' term | term
        choices: list[st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]] = []
        if (
            (a := self.sum(max_depth - 1),)
            and (
                literal := st.just(
                    Testcase(CodeItem.from_str("+"), fake_tokeninfo("+", token.STRING))
                ),
            )
            and (b := self.term(max_depth - 1),)
        ):

            def reducer(a, literal, b):
                return BinOp(left=a, op=Add(), right=b)

            sum_st = st.builds(Testcase.build, a, literal, b, reducer=st.just(reducer))
            choices.append(sum_st)
        if (
            (a := self.sum(max_depth - 1),)
            and (
                literal := st.just(
                    Testcase(CodeItem.from_str("-"), fake_tokeninfo("-", token.STRING))
                ),
            )
            and (b := self.term(max_depth - 1),)
        ):

            def reducer(a, literal, b):
                return BinOp(left=a, op=Sub(), right=b)

            sum_st = st.builds(Testcase.build, a, literal, b, reducer=st.just(reducer))
            choices.append(sum_st)
        if (term := self.term(max_depth - 1),):

            def reducer(term):
                return term

            sum_st = st.builds(Testcase.build, term, reducer=st.just(reducer))
            choices.append(sum_st)
        return st.one_of(choices)

    def term(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]:
        if max_depth <= 0:
            return st.nothing()
        # term: term '*' factor | term '/' factor | term '//' factor | term '%' factor | term '@' factor | factor
        choices: list[st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]] = []
        if (
            (a := self.term(max_depth - 1),)
            and (
                literal := st.just(
                    Testcase(CodeItem.from_str("*"), fake_tokeninfo("*", token.STRING))
                ),
            )
            and (b := self.factor(max_depth - 1),)
        ):

            def reducer(a, literal, b):
                return BinOp(left=a, op=Mult(), right=b)

            term_st = st.builds(Testcase.build, a, literal, b, reducer=st.just(reducer))
            choices.append(term_st)
        if (
            (a := self.term(max_depth - 1),)
            and (
                literal := st.just(
                    Testcase(CodeItem.from_str("/"), fake_tokeninfo("/", token.STRING))
                ),
            )
            and (b := self.factor(max_depth - 1),)
        ):

            def reducer(a, literal, b):
                return BinOp(left=a, op=Div(), right=b)

            term_st = st.builds(Testcase.build, a, literal, b, reducer=st.just(reducer))
            choices.append(term_st)
        if (
            (a := self.term(max_depth - 1),)
            and (
                literal := st.just(
                    Testcase(
                        CodeItem.from_str("//"), fake_tokeninfo("//", token.STRING)
                    )
                ),
            )
            and (b := self.factor(max_depth - 1),)
        ):

            def reducer(a, literal, b):
                return BinOp(left=a, op=FloorDiv(), right=b)

            term_st = st.builds(Testcase.build, a, literal, b, reducer=st.just(reducer))
            choices.append(term_st)
        if (
            (a := self.term(max_depth - 1),)
            and (
                literal := st.just(
                    Testcase(CodeItem.from_str("%"), fake_tokeninfo("%", token.STRING))
                ),
            )
            and (b := self.factor(max_depth - 1),)
        ):

            def reducer(a, literal, b):
                return BinOp(left=a, op=Mod(), right=b)

            term_st = st.builds(Testcase.build, a, literal, b, reducer=st.just(reducer))
            choices.append(term_st)
        if (
            (a := self.term(max_depth - 1),)
            and (
                literal := st.just(
                    Testcase(CodeItem.from_str("@"), fake_tokeninfo("@", token.STRING))
                ),
            )
            and (b := self.factor(max_depth - 1),)
        ):

            def reducer(a, literal, b):
                return BinOp(left=a, op=MatMult(), right=b)

            term_st = st.builds(Testcase.build, a, literal, b, reducer=st.just(reducer))
            choices.append(term_st)
        if (factor := self.factor(max_depth - 1),):

            def reducer(factor):
                return factor

            term_st = st.builds(Testcase.build, factor, reducer=st.just(reducer))
            choices.append(term_st)
        return st.one_of(choices)

    def factor(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]:
        if max_depth <= 0:
            return st.nothing()
        # factor: '+' factor | '-' factor | '~' factor | power
        choices: list[st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]] = []
        if (
            literal := st.just(
                Testcase(CodeItem.from_str("+"), fake_tokeninfo("+", token.STRING))
            ),
        ) and (a := self.factor(max_depth - 1),):

            def reducer(literal, a):
                return UnaryOp(op=UAdd(), operand=a)

            factor_st = st.builds(Testcase.build, literal, a, reducer=st.just(reducer))
            choices.append(factor_st)
        if (
            literal := st.just(
                Testcase(CodeItem.from_str("-"), fake_tokeninfo("-", token.STRING))
            ),
        ) and (a := self.factor(max_depth - 1),):

            def reducer(literal, a):
                return UnaryOp(op=USub(), operand=a)

            factor_st = st.builds(Testcase.build, literal, a, reducer=st.just(reducer))
            choices.append(factor_st)
        if (
            literal := st.just(
                Testcase(CodeItem.from_str("~"), fake_tokeninfo("~", token.STRING))
            ),
        ) and (a := self.factor(max_depth - 1),):

            def reducer(literal, a):
                return UnaryOp(op=Invert(), operand=a)

            factor_st = st.builds(Testcase.build, literal, a, reducer=st.just(reducer))
            choices.append(factor_st)
        if (power := self.power(max_depth - 1),):

            def reducer(power):
                return power

            factor_st = st.builds(Testcase.build, power, reducer=st.just(reducer))
            choices.append(factor_st)
        return st.one_of(choices)

    def power(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]:
        if max_depth <= 0:
            return st.nothing()
        # power: await_primary '**' factor | await_primary
        choices: list[st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]] = []
        if (
            (a := self.await_primary(max_depth - 1),)
            and (
                literal := st.just(
                    Testcase(
                        CodeItem.from_str("**"), fake_tokeninfo("**", token.STRING)
                    )
                ),
            )
            and (b := self.factor(max_depth - 1),)
        ):

            def reducer(a, literal, b):
                return BinOp(left=a, op=Pow(), right=b)

            power_st = st.builds(
                Testcase.build, a, literal, b, reducer=st.just(reducer)
            )
            choices.append(power_st)
        if (await_primary := self.await_primary(max_depth - 1),):

            def reducer(await_primary):
                return await_primary

            power_st = st.builds(
                Testcase.build, await_primary, reducer=st.just(reducer)
            )
            choices.append(power_st)
        return st.one_of(choices)

    def await_primary(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]:
        if max_depth <= 0:
            return st.nothing()
        # await_primary: 'await' primary | primary
        choices: list[st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]] = []
        if (
            literal := st.just(
                Testcase(
                    CodeItem.from_str("await"), fake_tokeninfo("await", token.STRING)
                )
            ),
        ) and (a := self.primary(max_depth - 1),):

            def reducer(literal, a):
                return Await(value=a)

            await_primary_st = st.builds(
                Testcase.build, literal, a, reducer=st.just(reducer)
            )
            choices.append(await_primary_st)
        if (primary := self.primary(max_depth - 1),):

            def reducer(primary):
                return primary

            await_primary_st = st.builds(
                Testcase.build, primary, reducer=st.just(reducer)
            )
            choices.append(await_primary_st)
        return st.one_of(choices)

    def primary(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]:
        if max_depth <= 0:
            return st.nothing()
        # primary: primary '.' id | primary '(' exprs? ')' | primary '[' expr ']' | atom
        choices: list[st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]] = []
        if (
            (a := self.primary(max_depth - 1),)
            and (
                literal := st.just(
                    Testcase(CodeItem.from_str("."), fake_tokeninfo(".", token.STRING))
                ),
            )
            and (b := self.id(max_depth - 1),)
        ):

            def reducer(a, literal, b):
                return Attribute(value=a, attr=b)

            primary_st = st.builds(
                Testcase.build, a, literal, b, reducer=st.just(reducer)
            )
            choices.append(primary_st)
        if (
            (a := self.primary(max_depth - 1),)
            and (
                literal := st.just(
                    Testcase(CodeItem.from_str("("), fake_tokeninfo("(", token.STRING))
                ),
            )
            and (
                args := st.one_of(
                    st.just(Testcase(CodeItem.from_str(""), None)),
                    self.exprs(max_depth - 1),
                ),
            )
            and (
                literal_1 := st.just(
                    Testcase(CodeItem.from_str(")"), fake_tokeninfo(")", token.STRING))
                ),
            )
        ):

            def reducer(a, literal, args, literal_1):
                return Call(func=a, args=args or [])

            primary_st = st.builds(
                Testcase.build, a, literal, args, literal_1, reducer=st.just(reducer)
            )
            choices.append(primary_st)
        if (
            (a := self.primary(max_depth - 1),)
            and (
                literal := st.just(
                    Testcase(CodeItem.from_str("["), fake_tokeninfo("[", token.STRING))
                ),
            )
            and (b := self.expr(max_depth - 1),)
            and (
                literal_1 := st.just(
                    Testcase(CodeItem.from_str("]"), fake_tokeninfo("]", token.STRING))
                ),
            )
        ):

            def reducer(a, literal, b, literal_1):
                return Subscript(value=a, slice=b)

            primary_st = st.builds(
                Testcase.build, a, literal, b, literal_1, reducer=st.just(reducer)
            )
            choices.append(primary_st)
        if (atom := self.atom(max_depth - 1),):

            def reducer(atom):
                return atom

            primary_st = st.builds(Testcase.build, atom, reducer=st.just(reducer))
            choices.append(primary_st)
        return st.one_of(choices)

    def atom(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]:
        if max_depth <= 0:
            return st.nothing()
        # atom: constant | dict_expr | set_expr | list_expr | tuple_expr | wildcard | name_expr | capture_pattern | capture_id | wildcard_id
        choices: list[st.SearchStrategy[tuple[list[CodeItem], ASTPattern[expr]]]] = []
        if (constant := self.constant(max_depth - 1),):

            def reducer(constant):
                return constant

            atom_st = st.builds(Testcase.build, constant, reducer=st.just(reducer))
            choices.append(atom_st)
        if (dict_expr := self.dict_expr(max_depth - 1),):

            def reducer(dict_expr):
                return dict_expr

            atom_st = st.builds(Testcase.build, dict_expr, reducer=st.just(reducer))
            choices.append(atom_st)
        if (set_expr := self.set_expr(max_depth - 1),):

            def reducer(set_expr):
                return set_expr

            atom_st = st.builds(Testcase.build, set_expr, reducer=st.just(reducer))
            choices.append(atom_st)
        if (list_expr := self.list_expr(max_depth - 1),):

            def reducer(list_expr):
                return list_expr

            atom_st = st.builds(Testcase.build, list_expr, reducer=st.just(reducer))
            choices.append(atom_st)
        if (tuple_expr := self.tuple_expr(max_depth - 1),):

            def reducer(tuple_expr):
                return tuple_expr

            atom_st = st.builds(Testcase.build, tuple_expr, reducer=st.just(reducer))
            choices.append(atom_st)
        if (wildcard := self.wildcard(max_depth - 1),):

            def reducer(wildcard):
                return wildcard

            atom_st = st.builds(Testcase.build, wildcard, reducer=st.just(reducer))
            choices.append(atom_st)
        if (name_expr := self.name_expr(max_depth - 1),):

            def reducer(name_expr):
                return name_expr

            atom_st = st.builds(Testcase.build, name_expr, reducer=st.just(reducer))
            choices.append(atom_st)
        if (c := self.capture_pattern(max_depth - 1),):

            def reducer(c):
                return c

            atom_st = st.builds(Testcase.build, c, reducer=st.just(reducer))
            choices.append(atom_st)
        if (c := self.capture_id(max_depth - 1),):

            def reducer(c):
                return Capture(name=c.name, pattern=expr())

            atom_st = st.builds(Testcase.build, c, reducer=st.just(reducer))
            choices.append(atom_st)
        if (w := self.wildcard_id(max_depth - 1),):

            def reducer(w):
                return Name()

            atom_st = st.builds(Testcase.build, w, reducer=st.just(reducer))
            choices.append(atom_st)
        return st.one_of(choices)

    def capture_pattern(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], Capture[ASTPattern[expr]]]]:
        if max_depth <= 0:
            return st.nothing()
        # capture_pattern: capture '{' expr '}'
        choices: list[
            st.SearchStrategy[tuple[list[CodeItem], Capture[ASTPattern[expr]]]]
        ] = []
        if (
            (c := self.capture(max_depth - 1),)
            and (
                literal := st.just(
                    Testcase(CodeItem.from_str("{"), fake_tokeninfo("{", token.STRING))
                ),
            )
            and (pattern := self.expr(max_depth - 1),)
            and (
                literal_1 := st.just(
                    Testcase(CodeItem.from_str("}"), fake_tokeninfo("}", token.STRING))
                ),
            )
        ):

            def reducer(c, literal, pattern, literal_1):
                return Capture(name=c, pattern=pattern)

            capture_pattern_st = st.builds(
                Testcase.build, c, literal, pattern, literal_1, reducer=st.just(reducer)
            )
            choices.append(capture_pattern_st)
        return st.one_of(choices)

    def list_expr(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], List]]:
        if max_depth <= 0:
            return st.nothing()
        # list_expr: '[' exprs? ']'
        choices: list[st.SearchStrategy[tuple[list[CodeItem], List]]] = []
        if (
            (
                literal := st.just(
                    Testcase(CodeItem.from_str("["), fake_tokeninfo("[", token.STRING))
                ),
            )
            and (
                a := st.one_of(
                    st.just(Testcase(CodeItem.from_str(""), None)),
                    self.exprs(max_depth - 1),
                ),
            )
            and (
                literal_1 := st.just(
                    Testcase(CodeItem.from_str("]"), fake_tokeninfo("]", token.STRING))
                ),
            )
        ):

            def reducer(literal, a, literal_1):
                return List(elts=a or [])

            list_expr_st = st.builds(
                Testcase.build, literal, a, literal_1, reducer=st.just(reducer)
            )
            choices.append(list_expr_st)
        return st.one_of(choices)

    def tuple_expr(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], Tuple]]:
        if max_depth <= 0:
            return st.nothing()
        # tuple_expr: '(' exprs? ')'
        choices: list[st.SearchStrategy[tuple[list[CodeItem], Tuple]]] = []
        if (
            (
                literal := st.just(
                    Testcase(CodeItem.from_str("("), fake_tokeninfo("(", token.STRING))
                ),
            )
            and (
                a := st.one_of(
                    st.just(Testcase(CodeItem.from_str(""), None)),
                    self.exprs(max_depth - 1),
                ),
            )
            and (
                literal_1 := st.just(
                    Testcase(CodeItem.from_str(")"), fake_tokeninfo(")", token.STRING))
                ),
            )
        ):

            def reducer(literal, a, literal_1):
                return Tuple(elts=a or [])

            tuple_expr_st = st.builds(
                Testcase.build, literal, a, literal_1, reducer=st.just(reducer)
            )
            choices.append(tuple_expr_st)
        return st.one_of(choices)

    def dict_expr(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], Dict]]:
        if max_depth <= 0:
            return st.nothing()
        # dict_expr: '{' dict '}'
        choices: list[st.SearchStrategy[tuple[list[CodeItem], Dict]]] = []
        if (
            (
                literal := st.just(
                    Testcase(CodeItem.from_str("{"), fake_tokeninfo("{", token.STRING))
                ),
            )
            and (d := self.dict(max_depth - 1),)
            and (
                literal_1 := st.just(
                    Testcase(CodeItem.from_str("}"), fake_tokeninfo("}", token.STRING))
                ),
            )
        ):

            def reducer(literal, d, literal_1):
                return Dict(keys=d[0], values=d[1])

            dict_expr_st = st.builds(
                Testcase.build, literal, d, literal_1, reducer=st.just(reducer)
            )
            choices.append(dict_expr_st)
        return st.one_of(choices)

    def set_expr(self, max_depth: int) -> st.SearchStrategy[tuple[list[CodeItem], Set]]:
        if max_depth <= 0:
            return st.nothing()
        # set_expr: '{' exprs? '}'
        choices: list[st.SearchStrategy[tuple[list[CodeItem], Set]]] = []
        if (
            (
                literal := st.just(
                    Testcase(CodeItem.from_str("{"), fake_tokeninfo("{", token.STRING))
                ),
            )
            and (
                e := st.one_of(
                    st.just(Testcase(CodeItem.from_str(""), None)),
                    self.exprs(max_depth - 1),
                ),
            )
            and (
                literal_1 := st.just(
                    Testcase(CodeItem.from_str("}"), fake_tokeninfo("}", token.STRING))
                ),
            )
        ):

            def reducer(literal, e, literal_1):
                return Set(elts=e or [])

            set_expr_st = st.builds(
                Testcase.build, literal, e, literal_1, reducer=st.just(reducer)
            )
            choices.append(set_expr_st)
        return st.one_of(choices)

    def wildcard(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], Wildcard]]:
        if max_depth <= 0:
            return st.nothing()
        # wildcard: '`'
        choices: list[st.SearchStrategy[tuple[list[CodeItem], Wildcard]]] = []
        if (
            literal := st.just(
                Testcase(CodeItem.from_str("`"), fake_tokeninfo("`", token.STRING))
            ),
        ):

            def reducer(literal):
                return Wildcard()

            wildcard_st = st.builds(Testcase.build, literal, reducer=st.just(reducer))
            choices.append(wildcard_st)
        return st.one_of(choices)

    def dict(
        self, max_depth: int
    ) -> st.SearchStrategy[
        tuple[
            list[CodeItem], tuple[list[ASTPattern[expr | None]], list[ASTPattern[expr]]]
        ]
    ]:
        if max_depth <= 0:
            return st.nothing()
        # dict: (expr ':' expr) ((',' expr ':' expr))*
        choices: list[
            st.SearchStrategy[
                tuple[
                    list[CodeItem],
                    tuple[list[ASTPattern[expr | None]], list[ASTPattern[expr]]],
                ]
            ]
        ] = []
        if (head := self._tmp_4(max_depth - 1),) and (
            tail := repeat_strategy(self._tmp_5(max_depth - 1), min_size=0),
        ):

            def reducer(head, tail):
                return _make_dict(head, tail)

            dict_st = st.builds(Testcase.build, head, tail, reducer=st.just(reducer))
            choices.append(dict_st)
        return st.one_of(choices)

    def name_expr(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], Name]]:
        if max_depth <= 0:
            return st.nothing()
        # name_expr: NAME
        choices: list[st.SearchStrategy[tuple[list[CodeItem], Name]]] = []
        if (n := self.name(max_depth - 1),):

            def reducer(n):
                return Name(id=n.string)

            name_expr_st = st.builds(Testcase.build, n, reducer=st.just(reducer))
            choices.append(name_expr_st)
        return st.one_of(choices)

    def id(
        self, max_depth: int
    ) -> st.SearchStrategy[
        tuple[list[CodeItem], Capture[_Identifier] | WildcardId | _Identifier]
    ]:
        if max_depth <= 0:
            return st.nothing()
        # id: capture_id | NAME | wildcard_id
        choices: list[
            st.SearchStrategy[
                tuple[list[CodeItem], Capture[_Identifier] | WildcardId | _Identifier]
            ]
        ] = []
        if (capture_id := self.capture_id(max_depth - 1),):

            def reducer(capture_id):
                return capture_id

            id_st = st.builds(Testcase.build, capture_id, reducer=st.just(reducer))
            choices.append(id_st)
        if (n := self.name(max_depth - 1),):

            def reducer(n):
                return n.string

            id_st = st.builds(Testcase.build, n, reducer=st.just(reducer))
            choices.append(id_st)
        if (wildcard_id := self.wildcard_id(max_depth - 1),):

            def reducer(wildcard_id):
                return wildcard_id

            id_st = st.builds(Testcase.build, wildcard_id, reducer=st.just(reducer))
            choices.append(id_st)
        return st.one_of(choices)

    def capture_id(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], Capture]]:
        if max_depth <= 0:
            return st.nothing()
        # capture_id: capture
        choices: list[st.SearchStrategy[tuple[list[CodeItem], Capture]]] = []
        if (c := self.capture(max_depth - 1),):

            def reducer(c):
                return Capture(name=c, pattern=WildcardId())

            capture_id_st = st.builds(Testcase.build, c, reducer=st.just(reducer))
            choices.append(capture_id_st)
        return st.one_of(choices)

    def wildcard_id(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], WildcardId]]:
        if max_depth <= 0:
            return st.nothing()
        # wildcard_id: '`'
        choices: list[st.SearchStrategy[tuple[list[CodeItem], WildcardId]]] = []
        if (
            literal := st.just(
                Testcase(CodeItem.from_str("`"), fake_tokeninfo("`", token.STRING))
            ),
        ):

            def reducer(literal):
                return WildcardId()

            wildcard_id_st = st.builds(
                Testcase.build, literal, reducer=st.just(reducer)
            )
            choices.append(wildcard_id_st)
        return st.one_of(choices)

    def capture(self, max_depth: int) -> st.SearchStrategy[tuple[list[CodeItem], str]]:
        if max_depth <= 0:
            return st.nothing()
        # capture: '$' NAME
        choices: list[st.SearchStrategy[tuple[list[CodeItem], str]]] = []
        if (
            literal := st.just(
                Testcase(CodeItem.from_str("$"), fake_tokeninfo("$", token.STRING))
            ),
        ) and (n := self.name(max_depth - 1),):

            def reducer(literal, n):
                return n.string

            capture_st = st.builds(Testcase.build, literal, n, reducer=st.just(reducer))
            choices.append(capture_st)
        return st.one_of(choices)

    def ellipsis(self, max_depth: int) -> st.SearchStrategy[tuple[list[CodeItem], Any]]:
        if max_depth <= 0:
            return st.nothing()
        # ellipsis: ':' | ':' '...'
        choices: list[st.SearchStrategy[tuple[list[CodeItem], Any]]] = []
        if (
            literal := st.just(
                Testcase(CodeItem.from_str(":"), fake_tokeninfo(":", token.STRING))
            ),
        ):

            def reducer(literal):
                return literal

            ellipsis_st = st.builds(Testcase.build, literal, reducer=st.just(reducer))
            choices.append(ellipsis_st)
        if (
            literal := st.just(
                Testcase(CodeItem.from_str(":"), fake_tokeninfo(":", token.STRING))
            ),
        ) and (
            literal_1 := st.just(
                Testcase(CodeItem.from_str("..."), fake_tokeninfo("...", token.STRING))
            ),
        ):

            def reducer(literal, literal_1):
                return [literal, literal_1]

            ellipsis_st = st.builds(
                Testcase.build, literal, literal_1, reducer=st.just(reducer)
            )
            choices.append(ellipsis_st)
        return st.one_of(choices)

    def constant(
        self, max_depth: int
    ) -> st.SearchStrategy[tuple[list[CodeItem], Constant]]:
        if max_depth <= 0:
            return st.nothing()
        # constant: 'None' | 'True' | 'False' | NUMBER | STRING
        choices: list[st.SearchStrategy[tuple[list[CodeItem], Constant]]] = []
        if (
            literal := st.just(
                Testcase(
                    CodeItem.from_str("None"), fake_tokeninfo("None", token.STRING)
                )
            ),
        ):

            def reducer(literal):
                return Constant(value=None)

            constant_st = st.builds(Testcase.build, literal, reducer=st.just(reducer))
            choices.append(constant_st)
        if (
            literal := st.just(
                Testcase(
                    CodeItem.from_str("True"), fake_tokeninfo("True", token.STRING)
                )
            ),
        ):

            def reducer(literal):
                return Constant(value=True)

            constant_st = st.builds(Testcase.build, literal, reducer=st.just(reducer))
            choices.append(constant_st)
        if (
            literal := st.just(
                Testcase(
                    CodeItem.from_str("False"), fake_tokeninfo("False", token.STRING)
                )
            ),
        ):

            def reducer(literal):
                return Constant(value=False)

            constant_st = st.builds(Testcase.build, literal, reducer=st.just(reducer))
            choices.append(constant_st)
        if (n := self.number(max_depth - 1),):

            def reducer(n):
                return Constant(value=ast.literal_eval(n.string))

            constant_st = st.builds(Testcase.build, n, reducer=st.just(reducer))
            choices.append(constant_st)
        if (s := self.string(max_depth - 1),):

            def reducer(s):
                return Constant(value=s.string)

            constant_st = st.builds(Testcase.build, s, reducer=st.just(reducer))
            choices.append(constant_st)
        return st.one_of(choices)

    def _tmp_1(self, max_depth: int) -> st.SearchStrategy[tuple[list[CodeItem], Any]]:
        if max_depth <= 0:
            return st.nothing()
        # _tmp_1: '=' ellipsis?
        choices: list[st.SearchStrategy[tuple[list[CodeItem], Any]]] = []
        if (
            literal := st.just(
                Testcase(CodeItem.from_str("="), fake_tokeninfo("=", token.STRING))
            ),
        ) and (
            opt := st.one_of(
                st.just(Testcase(CodeItem.from_str(""), None)),
                self.ellipsis(max_depth - 1),
            ),
        ):

            def reducer(literal, opt):
                return [literal, opt]

            _tmp_1_st = st.builds(
                Testcase.build, literal, opt, reducer=st.just(reducer)
            )
            choices.append(_tmp_1_st)
        return st.one_of(choices)

    def _tmp_2(self, max_depth: int) -> st.SearchStrategy[tuple[list[CodeItem], Any]]:
        if max_depth <= 0:
            return st.nothing()
        # _tmp_2: 'or' conjunction
        choices: list[st.SearchStrategy[tuple[list[CodeItem], Any]]] = []
        if (
            literal := st.just(
                Testcase(CodeItem.from_str("or"), fake_tokeninfo("or", token.STRING))
            ),
        ) and (c := self.conjunction(max_depth - 1),):

            def reducer(literal, c):
                return c

            _tmp_2_st = st.builds(Testcase.build, literal, c, reducer=st.just(reducer))
            choices.append(_tmp_2_st)
        return st.one_of(choices)

    def _tmp_3(self, max_depth: int) -> st.SearchStrategy[tuple[list[CodeItem], Any]]:
        if max_depth <= 0:
            return st.nothing()
        # _tmp_3: 'and' inversion
        choices: list[st.SearchStrategy[tuple[list[CodeItem], Any]]] = []
        if (
            literal := st.just(
                Testcase(CodeItem.from_str("and"), fake_tokeninfo("and", token.STRING))
            ),
        ) and (c := self.inversion(max_depth - 1),):

            def reducer(literal, c):
                return c

            _tmp_3_st = st.builds(Testcase.build, literal, c, reducer=st.just(reducer))
            choices.append(_tmp_3_st)
        return st.one_of(choices)

    def _tmp_4(self, max_depth: int) -> st.SearchStrategy[tuple[list[CodeItem], Any]]:
        if max_depth <= 0:
            return st.nothing()
        # _tmp_4: expr ':' expr
        choices: list[st.SearchStrategy[tuple[list[CodeItem], Any]]] = []
        if (
            (k := self.expr(max_depth - 1),)
            and (
                literal := st.just(
                    Testcase(CodeItem.from_str(":"), fake_tokeninfo(":", token.STRING))
                ),
            )
            and (v := self.expr(max_depth - 1),)
        ):

            def reducer(k, literal, v):
                return [k, literal, v]

            _tmp_4_st = st.builds(
                Testcase.build, k, literal, v, reducer=st.just(reducer)
            )
            choices.append(_tmp_4_st)
        return st.one_of(choices)

    def _tmp_5(self, max_depth: int) -> st.SearchStrategy[tuple[list[CodeItem], Any]]:
        if max_depth <= 0:
            return st.nothing()
        # _tmp_5: ',' expr ':' expr
        choices: list[st.SearchStrategy[tuple[list[CodeItem], Any]]] = []
        if (
            (
                literal := st.just(
                    Testcase(CodeItem.from_str(","), fake_tokeninfo(",", token.STRING))
                ),
            )
            and (k := self.expr(max_depth - 1),)
            and (
                literal_1 := st.just(
                    Testcase(CodeItem.from_str(":"), fake_tokeninfo(":", token.STRING))
                ),
            )
            and (v := self.expr(max_depth - 1),)
        ):

            def reducer(literal, k, literal_1, v):
                return [literal, k, literal_1, v]

            _tmp_5_st = st.builds(
                Testcase.build, literal, k, literal_1, v, reducer=st.just(reducer)
            )
            choices.append(_tmp_5_st)
        return st.one_of(choices)
