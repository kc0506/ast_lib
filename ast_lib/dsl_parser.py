#!/usr/bin/env python3.8
# @generated by pegen from C:\Users\kchon\OneDrive\Desktop\ast_lib\scripts\data\match.gram
# pyright: reportUnusedVariable=false, reportUnusedImport=false, reportIncompatibleMethodOverride=false, reportUnusedParameter=false
# ruff: noqa: F401, F841, E703, F405, F403, F634

from __future__ import annotations


import ast
import sys
import tokenize

from typing import Any, Optional, TYPE_CHECKING, cast

from rich import print
from pegen.parser import memoize, memoize_left_rec, logger, Parser
from functools import reduce, wraps
from .nodes import *

def wrap_start(fn):
    @wraps(fn)
    def wrapper(self, *args, **kwargs):
        ret = fn(self, *args, **kwargs)
        return ret
    return wrapper

def wrap_stmt(fn):
    @wraps(fn)
    def wrapper(self, *args, **kwargs):
        lineno = self._tokenizer.peek().start[0]
        ret = fn(self, *args, **kwargs)
        return ret
    return wrapper

def _reduce_chain(p, s):
    def reducer(acc, suffix):
        if suffix['type'] == 'Call':
            return Call(func=acc, args=suffix['args'])
        if suffix['type'] == 'Attribute':
            return Attribute(value=acc, attr=suffix['attr'])
        if suffix['type'] == 'Subscript':
            return Subscript(value=acc, slice=suffix['slice'])
        return acc
    
    return reduce(reducer, s, p)

def _make_dict(head, tail):
    return tuple(zip(*[head] + [(k, v) for _, k, __, v in tail]))


# Keywords and soft keywords are listed at the end of the parser definition.
class DSLParser(Parser):

    @wrap_start
    @memoize
    def start(self) -> Optional[Any]:
        # start: stmts $
        mark = self._mark()
        if (
            (stmts := self.stmts())
            and
            (self.expect('ENDMARKER'))
        ):
            return stmts;
        self._reset(mark)
        return None;

    @memoize
    def stmts(self) -> Optional[list [stmt]]:
        # stmts: stmt '\n' stmts | stmt '\n' | stmt
        mark = self._mark()
        if (
            (s := self.stmt())
            and
            (self.expect('\n'))
            and
            (rest := self.stmts())
        ):
            return [s , * rest];
        self._reset(mark)
        if (
            (s := self.stmt())
            and
            (self.expect('\n'))
        ):
            return [s];
        self._reset(mark)
        if (
            (s := self.stmt())
        ):
            return [s];
        self._reset(mark)
        return None;

    @wrap_stmt
    @memoize
    def stmt(self) -> Optional[stmt]:
        # stmt: function_def | async_function_def | class_def | return_stmt | delete_stmt | assign | ann_assign | for_stmt | async_for | while_stmt | if_stmt | expr_stmt
        mark = self._mark()
        if (
            (function_def := self.function_def())
        ):
            return function_def;
        self._reset(mark)
        if (
            (async_function_def := self.async_function_def())
        ):
            return async_function_def;
        self._reset(mark)
        if (
            (class_def := self.class_def())
        ):
            return class_def;
        self._reset(mark)
        if (
            (return_stmt := self.return_stmt())
        ):
            return return_stmt;
        self._reset(mark)
        if (
            (delete_stmt := self.delete_stmt())
        ):
            return delete_stmt;
        self._reset(mark)
        if (
            (assign := self.assign())
        ):
            return assign;
        self._reset(mark)
        if (
            (ann_assign := self.ann_assign())
        ):
            return ann_assign;
        self._reset(mark)
        if (
            (for_stmt := self.for_stmt())
        ):
            return for_stmt;
        self._reset(mark)
        if (
            (async_for := self.async_for())
        ):
            return async_for;
        self._reset(mark)
        if (
            (while_stmt := self.while_stmt())
        ):
            return while_stmt;
        self._reset(mark)
        if (
            (if_stmt := self.if_stmt())
        ):
            return if_stmt;
        self._reset(mark)
        if (
            (expr_stmt := self.expr_stmt())
        ):
            return expr_stmt;
        self._reset(mark)
        return None;

    @memoize
    def function_def(self) -> Optional[FunctionDef]:
        # function_def: decorators? 'def' id '(' args? ')' ellipsis?
        mark = self._mark()
        if (
            (d := self.decorators(),)
            and
            (self.expect('def'))
            and
            (n := self.id())
            and
            (self.expect('('))
            and
            (a := self.args(),)
            and
            (self.expect(')'))
            and
            (self.ellipsis(),)
        ):
            return FunctionDef ( name = n , decorator_list = d or [] , args = a or Wildcard ( ) );
        self._reset(mark)
        return None;

    @memoize
    def async_function_def(self) -> Optional[AsyncFunctionDef]:
        # async_function_def: decorators? 'async' 'def' id '(' args? ')' ellipsis?
        mark = self._mark()
        if (
            (d := self.decorators(),)
            and
            (self.expect('async'))
            and
            (self.expect('def'))
            and
            (n := self.id())
            and
            (self.expect('('))
            and
            (a := self.args(),)
            and
            (self.expect(')'))
            and
            (self.ellipsis(),)
        ):
            return AsyncFunctionDef ( name = n , decorator_list = d or [] , args = a or arguments . make_empty ( ) );
        self._reset(mark)
        return None;

    @memoize
    def class_def(self) -> Optional[ClassDef]:
        # class_def: decorators? 'class' id class_bases? ellipsis?
        mark = self._mark()
        if (
            (d := self.decorators(),)
            and
            (self.expect('class'))
            and
            (n := self.id())
            and
            (bases := self.class_bases(),)
            and
            (self.ellipsis(),)
        ):
            return ClassDef ( name = n , bases = bases or [] , decorator_list = d or [] );
        self._reset(mark)
        return None;

    @memoize
    def return_stmt(self) -> Optional[Return]:
        # return_stmt: 'return' expr
        mark = self._mark()
        if (
            (self.expect('return'))
            and
            (e := self.expr())
        ):
            return Return ( value = e );
        self._reset(mark)
        return None;

    @memoize
    def delete_stmt(self) -> Optional[Delete]:
        # delete_stmt: 'delete' exprs
        mark = self._mark()
        if (
            (self.expect('delete'))
            and
            (e := self.exprs())
        ):
            return Delete ( targets = e );
        self._reset(mark)
        return None;

    @memoize
    def assign(self) -> Optional[Assign]:
        # assign: exprs '=' expr
        mark = self._mark()
        if (
            (targets := self.exprs())
            and
            (self.expect('='))
            and
            (value := self.expr())
        ):
            return Assign ( targets = targets , value = value );
        self._reset(mark)
        return None;

    @memoize
    def ann_assign(self) -> Optional[AnnAssign]:
        # ann_assign: expr ':' expr '=' expr
        mark = self._mark()
        if (
            (target := cast(Name | Attribute | Subscript, self.expr()))
            and
            (self.expect(':'))
            and
            (ann := self.expr())
            and
            (self.expect('='))
            and
            (value := self.expr())
        ):
            return AnnAssign ( target = target , annotation = ann , value = value );
        self._reset(mark)
        return None;

    @memoize
    def for_stmt(self) -> Optional[For]:
        # for_stmt: 'for' expr 'in' expr ellipsis?
        mark = self._mark()
        if (
            (self.expect('for'))
            and
            (target := self.expr())
            and
            (self.expect('in'))
            and
            (iter := self.expr())
            and
            (self.ellipsis(),)
        ):
            return For ( target = target , iter = iter );
        self._reset(mark)
        return None;

    @memoize
    def async_for(self) -> Optional[AsyncFor]:
        # async_for: 'async' 'for' expr 'in' expr ellipsis?
        mark = self._mark()
        if (
            (self.expect('async'))
            and
            (self.expect('for'))
            and
            (target := self.expr())
            and
            (self.expect('in'))
            and
            (iter := self.expr())
            and
            (self.ellipsis(),)
        ):
            return AsyncFor ( target = target , iter = iter );
        self._reset(mark)
        return None;

    @memoize
    def while_stmt(self) -> Optional[While]:
        # while_stmt: 'while' expr ellipsis?
        mark = self._mark()
        if (
            (self.expect('while'))
            and
            (test := self.expr())
            and
            (self.ellipsis(),)
        ):
            return While ( test = test );
        self._reset(mark)
        return None;

    @memoize
    def if_stmt(self) -> Optional[If]:
        # if_stmt: 'if' expr [('=' ellipsis?)]
        mark = self._mark()
        if (
            (self.expect('if'))
            and
            (test := self.expr())
            and
            (self._tmp_1(),)
        ):
            return If ( test = test );
        self._reset(mark)
        return None;

    @memoize
    def expr_stmt(self) -> Optional[Expr]:
        # expr_stmt: expr
        mark = self._mark()
        if (
            (e := self.expr())
        ):
            return Expr ( value = e );
        self._reset(mark)
        return None;

    @memoize
    def decorators(self) -> Optional[list [ASTPattern [expr]]]:
        # decorators: '\n'.decorator+
        mark = self._mark()
        if (
            (_gather_2 := self._gather_2())
        ):
            return _gather_2;
        self._reset(mark)
        return None;

    @memoize
    def decorator(self) -> Optional[ASTPattern [expr]]:
        # decorator: '@' expr
        mark = self._mark()
        if (
            (self.expect('@'))
            and
            (e := self.expr())
        ):
            return e;
        self._reset(mark)
        return None;

    @memoize
    def class_bases(self) -> Optional[list [ASTPattern [expr]]]:
        # class_bases: '(' exprs ')'
        mark = self._mark()
        if (
            (self.expect('('))
            and
            (e := self.exprs())
            and
            (self.expect(')'))
        ):
            return e;
        self._reset(mark)
        return None;

    @memoize
    def exprs(self) -> Optional[list [ASTPattern [expr]]]:
        # exprs: ','.expr+ ','?
        mark = self._mark()
        if (
            (e := self._gather_4())
            and
            (self.expect(','),)
        ):
            return e;
        self._reset(mark)
        return None;

    @memoize
    def args(self) -> Optional[arguments]:
        # args: exprs
        mark = self._mark()
        if (
            (exprs := self.exprs())
        ):
            return exprs;
        self._reset(mark)
        return None;

    @memoize
    def expr(self) -> Optional[ASTPattern [expr]]:
        # expr: disjunction
        mark = self._mark()
        if (
            (disjunction := self.disjunction())
        ):
            return disjunction;
        self._reset(mark)
        return None;

    @memoize
    def disjunction(self) -> Optional[ASTPattern [expr]]:
        # disjunction: conjunction (('or' conjunction))+ | conjunction
        mark = self._mark()
        if (
            (a := self.conjunction())
            and
            (b := self._loop1_6())
        ):
            return BoolOp ( op = Or ( ) , values = [a , * b] );
        self._reset(mark)
        if (
            (conjunction := self.conjunction())
        ):
            return conjunction;
        self._reset(mark)
        return None;

    @memoize
    def conjunction(self) -> Optional[ASTPattern [expr]]:
        # conjunction: inversion (('and' inversion))+ | inversion
        mark = self._mark()
        if (
            (a := self.inversion())
            and
            (b := self._loop1_7())
        ):
            return BoolOp ( op = And ( ) , values = [a , * b] );
        self._reset(mark)
        if (
            (inversion := self.inversion())
        ):
            return inversion;
        self._reset(mark)
        return None;

    @memoize
    def inversion(self) -> Optional[ASTPattern [expr]]:
        # inversion: 'not' inversion | comparison
        mark = self._mark()
        if (
            (self.expect('not'))
            and
            (a := self.inversion())
        ):
            return UnaryOp ( op = Not ( ) , operand = a );
        self._reset(mark)
        if (
            (comparison := self.comparison())
        ):
            return comparison;
        self._reset(mark)
        return None;

    @memoize
    def comparison(self) -> Optional[ASTPattern [expr]]:
        # comparison: bitwise_or compare_op_bitwise_or_pair+ | bitwise_or
        mark = self._mark()
        if (
            (a := self.bitwise_or())
            and
            (b := self._loop1_8())
        ):
            return Compare ( left = a , ops = [pair ['op'] for pair in b] , comparators = [pair ['comparator'] for pair in b] );
        self._reset(mark)
        if (
            (bitwise_or := self.bitwise_or())
        ):
            return bitwise_or;
        self._reset(mark)
        return None;

    @memoize
    def compare_op_bitwise_or_pair(self) -> Optional[dict]:
        # compare_op_bitwise_or_pair: '==' bitwise_or | '!=' bitwise_or | '<=' bitwise_or | '<' bitwise_or | '>=' bitwise_or | '>' bitwise_or | 'not' 'in' bitwise_or | 'in' bitwise_or | 'is' 'not' bitwise_or | 'is' bitwise_or
        mark = self._mark()
        if (
            (self.expect('=='))
            and
            (b := self.bitwise_or())
        ):
            return {'op' : Eq ( ) , 'comparator' : b};
        self._reset(mark)
        if (
            (self.expect('!='))
            and
            (b := self.bitwise_or())
        ):
            return {'op' : NotEq ( ) , 'comparator' : b};
        self._reset(mark)
        if (
            (self.expect('<='))
            and
            (b := self.bitwise_or())
        ):
            return {'op' : LtE ( ) , 'comparator' : b};
        self._reset(mark)
        if (
            (self.expect('<'))
            and
            (b := self.bitwise_or())
        ):
            return {'op' : Lt ( ) , 'comparator' : b};
        self._reset(mark)
        if (
            (self.expect('>='))
            and
            (b := self.bitwise_or())
        ):
            return {'op' : GtE ( ) , 'comparator' : b};
        self._reset(mark)
        if (
            (self.expect('>'))
            and
            (b := self.bitwise_or())
        ):
            return {'op' : Gt ( ) , 'comparator' : b};
        self._reset(mark)
        if (
            (self.expect('not'))
            and
            (self.expect('in'))
            and
            (b := self.bitwise_or())
        ):
            return {'op' : NotIn ( ) , 'comparator' : b};
        self._reset(mark)
        if (
            (self.expect('in'))
            and
            (b := self.bitwise_or())
        ):
            return {'op' : In ( ) , 'comparator' : b};
        self._reset(mark)
        if (
            (self.expect('is'))
            and
            (self.expect('not'))
            and
            (b := self.bitwise_or())
        ):
            return {'op' : IsNot ( ) , 'comparator' : b};
        self._reset(mark)
        if (
            (self.expect('is'))
            and
            (b := self.bitwise_or())
        ):
            return {'op' : Is ( ) , 'comparator' : b};
        self._reset(mark)
        return None;

    @memoize_left_rec
    def bitwise_or(self) -> Optional[ASTPattern [expr]]:
        # bitwise_or: bitwise_or '|' bitwise_xor | bitwise_xor
        mark = self._mark()
        if (
            (a := self.bitwise_or())
            and
            (self.expect('|'))
            and
            (b := self.bitwise_xor())
        ):
            return BinOp ( left = a , op = BitOr ( ) , right = b );
        self._reset(mark)
        if (
            (bitwise_xor := self.bitwise_xor())
        ):
            return bitwise_xor;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def bitwise_xor(self) -> Optional[ASTPattern [expr]]:
        # bitwise_xor: bitwise_xor '^' bitwise_and | bitwise_and
        mark = self._mark()
        if (
            (a := self.bitwise_xor())
            and
            (self.expect('^'))
            and
            (b := self.bitwise_and())
        ):
            return BinOp ( left = a , op = BitXor ( ) , right = b );
        self._reset(mark)
        if (
            (bitwise_and := self.bitwise_and())
        ):
            return bitwise_and;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def bitwise_and(self) -> Optional[ASTPattern [expr]]:
        # bitwise_and: bitwise_and '&' shift_expr | shift_expr
        mark = self._mark()
        if (
            (a := self.bitwise_and())
            and
            (self.expect('&'))
            and
            (b := self.shift_expr())
        ):
            return BinOp ( left = a , op = BitAnd ( ) , right = b );
        self._reset(mark)
        if (
            (shift_expr := self.shift_expr())
        ):
            return shift_expr;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def shift_expr(self) -> Optional[ASTPattern [expr]]:
        # shift_expr: shift_expr '<<' sum | shift_expr '>>' sum | sum
        mark = self._mark()
        if (
            (a := self.shift_expr())
            and
            (self.expect('<<'))
            and
            (b := self.sum())
        ):
            return BinOp ( left = a , op = LShift ( ) , right = b );
        self._reset(mark)
        if (
            (a := self.shift_expr())
            and
            (self.expect('>>'))
            and
            (b := self.sum())
        ):
            return BinOp ( left = a , op = RShift ( ) , right = b );
        self._reset(mark)
        if (
            (sum := self.sum())
        ):
            return sum;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def sum(self) -> Optional[ASTPattern [expr]]:
        # sum: sum '+' term | sum '-' term | term
        mark = self._mark()
        if (
            (a := self.sum())
            and
            (self.expect('+'))
            and
            (b := self.term())
        ):
            return BinOp ( left = a , op = Add ( ) , right = b );
        self._reset(mark)
        if (
            (a := self.sum())
            and
            (self.expect('-'))
            and
            (b := self.term())
        ):
            return BinOp ( left = a , op = Sub ( ) , right = b );
        self._reset(mark)
        if (
            (term := self.term())
        ):
            return term;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def term(self) -> Optional[ASTPattern [expr]]:
        # term: term '*' factor | term '/' factor | term '//' factor | term '%' factor | term '@' factor | factor
        mark = self._mark()
        if (
            (a := self.term())
            and
            (self.expect('*'))
            and
            (b := self.factor())
        ):
            return BinOp ( left = a , op = Mult ( ) , right = b );
        self._reset(mark)
        if (
            (a := self.term())
            and
            (self.expect('/'))
            and
            (b := self.factor())
        ):
            return BinOp ( left = a , op = Div ( ) , right = b );
        self._reset(mark)
        if (
            (a := self.term())
            and
            (self.expect('//'))
            and
            (b := self.factor())
        ):
            return BinOp ( left = a , op = FloorDiv ( ) , right = b );
        self._reset(mark)
        if (
            (a := self.term())
            and
            (self.expect('%'))
            and
            (b := self.factor())
        ):
            return BinOp ( left = a , op = Mod ( ) , right = b );
        self._reset(mark)
        if (
            (a := self.term())
            and
            (self.expect('@'))
            and
            (b := self.factor())
        ):
            return BinOp ( left = a , op = MatMult ( ) , right = b );
        self._reset(mark)
        if (
            (factor := self.factor())
        ):
            return factor;
        self._reset(mark)
        return None;

    @memoize
    def factor(self) -> Optional[ASTPattern [expr]]:
        # factor: '+' factor | '-' factor | power
        mark = self._mark()
        if (
            (self.expect('+'))
            and
            (a := self.factor())
        ):
            return UnaryOp ( op = UAdd ( ) , operand = a );
        self._reset(mark)
        if (
            (self.expect('-'))
            and
            (a := self.factor())
        ):
            return UnaryOp ( op = USub ( ) , operand = a );
        self._reset(mark)
        if (
            (power := self.power())
        ):
            return power;
        self._reset(mark)
        return None;

    @memoize
    def power(self) -> Optional[ASTPattern [expr]]:
        # power: await_primary '**' factor | await_primary
        mark = self._mark()
        if (
            (a := self.await_primary())
            and
            (self.expect('**'))
            and
            (b := self.factor())
        ):
            return BinOp ( left = a , op = Pow ( ) , right = b );
        self._reset(mark)
        if (
            (await_primary := self.await_primary())
        ):
            return await_primary;
        self._reset(mark)
        return None;

    @memoize
    def await_primary(self) -> Optional[ASTPattern [expr]]:
        # await_primary: 'await' primary | primary
        mark = self._mark()
        if (
            (self.expect('await'))
            and
            (a := self.primary())
        ):
            return Await ( value = a );
        self._reset(mark)
        if (
            (primary := self.primary())
        ):
            return primary;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def primary(self) -> Optional[ASTPattern [expr]]:
        # primary: primary '.' id | primary '(' exprs? ')' | primary '[' expr ']' | atom
        mark = self._mark()
        if (
            (a := self.primary())
            and
            (self.expect('.'))
            and
            (b := self.id())
        ):
            return Attribute ( value = a , attr = b );
        self._reset(mark)
        if (
            (a := self.primary())
            and
            (self.expect('('))
            and
            (args := self.exprs(),)
            and
            (self.expect(')'))
        ):
            return Call ( func = a , args = args or Wildcard ( ) );
        self._reset(mark)
        if (
            (a := self.primary())
            and
            (self.expect('['))
            and
            (b := self.expr())
            and
            (self.expect(']'))
        ):
            return Subscript ( value = a , slice = b );
        self._reset(mark)
        if (
            (atom := self.atom())
        ):
            return atom;
        self._reset(mark)
        return None;

    @memoize
    def atom(self) -> Optional[ASTPattern [expr]]:
        # atom: constant | dict_expr | set_expr | list_expr | tuple_expr | wildcard | name_expr | capture_pattern | capture_id | wildcard_id
        mark = self._mark()
        if (
            (constant := self.constant())
        ):
            return constant;
        self._reset(mark)
        if (
            (dict_expr := self.dict_expr())
        ):
            return dict_expr;
        self._reset(mark)
        if (
            (set_expr := self.set_expr())
        ):
            return set_expr;
        self._reset(mark)
        if (
            (list_expr := self.list_expr())
        ):
            return list_expr;
        self._reset(mark)
        if (
            (tuple_expr := self.tuple_expr())
        ):
            return tuple_expr;
        self._reset(mark)
        if (
            (wildcard := self.wildcard())
        ):
            return wildcard;
        self._reset(mark)
        if (
            (name_expr := self.name_expr())
        ):
            return name_expr;
        self._reset(mark)
        if (
            (c := self.capture_pattern())
        ):
            return c;
        self._reset(mark)
        if (
            (c := self.capture_id())
        ):
            return Capture ( name = c . name , pattern = expr ( ) );
        self._reset(mark)
        if (
            (self.wildcard_id())
        ):
            return Name ( );
        self._reset(mark)
        return None;

    @memoize
    def capture_pattern(self) -> Optional[Capture [ASTPattern [expr]]]:
        # capture_pattern: capture '{' expr '}'
        mark = self._mark()
        if (
            (c := self.capture())
            and
            (self.expect('{'))
            and
            (pattern := self.expr())
            and
            (self.expect('}'))
        ):
            return Capture ( name = c ['name'] , pattern = pattern );
        self._reset(mark)
        return None;

    @memoize
    def list_expr(self) -> Optional[List]:
        # list_expr: '[' exprs? ']'
        mark = self._mark()
        if (
            (self.expect('['))
            and
            (a := self.exprs(),)
            and
            (self.expect(']'))
        ):
            return List ( elts = a or [] );
        self._reset(mark)
        return None;

    @memoize
    def tuple_expr(self) -> Optional[Tuple]:
        # tuple_expr: '(' exprs? ')'
        mark = self._mark()
        if (
            (self.expect('('))
            and
            (a := self.exprs(),)
            and
            (self.expect(')'))
        ):
            return Tuple ( elts = a or [] );
        self._reset(mark)
        return None;

    @memoize
    def dict_expr(self) -> Optional[Dict]:
        # dict_expr: '{' dict '}'
        mark = self._mark()
        if (
            (self.expect('{'))
            and
            (d := self.dict())
            and
            (self.expect('}'))
        ):
            return Dict ( keys = d [0] , values = d [1] );
        self._reset(mark)
        return None;

    @memoize
    def set_expr(self) -> Optional[Set]:
        # set_expr: '{' exprs? '}'
        mark = self._mark()
        if (
            (self.expect('{'))
            and
            (e := self.exprs(),)
            and
            (self.expect('}'))
        ):
            return Set ( elts = e or [] );
        self._reset(mark)
        return None;

    @memoize
    def wildcard(self) -> Optional[Wildcard]:
        # wildcard: '~'
        mark = self._mark()
        if (
            (self.expect('~'))
        ):
            return Wildcard ( );
        self._reset(mark)
        return None;

    @memoize
    def dict(self) -> Optional[tuple [list [ASTPattern [expr | None]] , list [ASTPattern [expr]]]]:
        # dict: (expr ':' expr) ((',' expr ':' expr))*
        mark = self._mark()
        if (
            (head := self._tmp_9())
            and
            (tail := self._loop0_10(),)
        ):
            return _make_dict ( head , tail );
        self._reset(mark)
        return None;

    @memoize
    def name_expr(self) -> Optional[Name]:
        # name_expr: NAME
        mark = self._mark()
        if (
            (n := self.name())
        ):
            return Name ( id = n . string );
        self._reset(mark)
        return None;

    @memoize
    def id(self) -> Optional[Capture [_Identifier] | WildcardId | _Identifier]:
        # id: capture_id | NAME | wildcard_id
        mark = self._mark()
        if (
            (capture_id := self.capture_id())
        ):
            return capture_id;
        self._reset(mark)
        if (
            (n := self.name())
        ):
            return n . string;
        self._reset(mark)
        if (
            (wildcard_id := self.wildcard_id())
        ):
            return wildcard_id;
        self._reset(mark)
        return None;

    @memoize
    def capture_id(self) -> Optional[Capture]:
        # capture_id: capture
        mark = self._mark()
        if (
            (c := self.capture())
        ):
            return Capture ( name = c ['name'] , pattern = WildcardId ( ) );
        self._reset(mark)
        return None;

    @memoize
    def wildcard_id(self) -> Optional[WildcardId]:
        # wildcard_id: '`'
        mark = self._mark()
        if (
            (self.expect('`'))
        ):
            return WildcardId ( );
        self._reset(mark)
        return None;

    @memoize
    def capture(self) -> Optional[dict [str , str | int]]:
        # capture: '$' NAME | '$' NUMBER
        mark = self._mark()
        if (
            (self.expect('$'))
            and
            (n := self.name())
        ):
            return {'name' : n . string};
        self._reset(mark)
        if (
            (self.expect('$'))
            and
            (n := self.number())
        ):
            return {'name' : int ( n . string )};
        self._reset(mark)
        return None;

    @memoize
    def ellipsis(self) -> Optional[Any]:
        # ellipsis: ':' '...' | ':'
        mark = self._mark()
        if (
            (literal := self.expect(':'))
            and
            (literal_1 := self.expect('...'))
        ):
            return [literal, literal_1];
        self._reset(mark)
        if (
            (literal := self.expect(':'))
        ):
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def constant(self) -> Optional[Constant]:
        # constant: 'None' | 'True' | 'False' | NUMBER | STRING
        mark = self._mark()
        if (
            (self.expect('None'))
        ):
            return Constant ( value = None );
        self._reset(mark)
        if (
            (self.expect('True'))
        ):
            return Constant ( value = True );
        self._reset(mark)
        if (
            (self.expect('False'))
        ):
            return Constant ( value = False );
        self._reset(mark)
        if (
            (n := self.number())
        ):
            return Constant ( value = ast . literal_eval ( n . string ) );
        self._reset(mark)
        if (
            (s := self.string())
        ):
            return Constant ( value = s . string );
        self._reset(mark)
        return None;

    @memoize
    def _tmp_1(self) -> Optional[Any]:
        # _tmp_1: '=' ellipsis?
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (opt := self.ellipsis(),)
        ):
            return [literal, opt];
        self._reset(mark)
        return None;

    @memoize
    def _loop0_3(self) -> Optional[Any]:
        # _loop0_3: '\n' decorator
        mark = self._mark()
        children = []
        while (
            (self.expect('\n'))
            and
            (elem := self.decorator())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_2(self) -> Optional[Any]:
        # _gather_2: decorator _loop0_3
        mark = self._mark()
        if (
            (elem := self.decorator())
            is not None
            and
            (seq := self._loop0_3())
            is not None
        ):
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_5(self) -> Optional[Any]:
        # _loop0_5: ',' expr
        mark = self._mark()
        children = []
        while (
            (self.expect(','))
            and
            (elem := self.expr())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_4(self) -> Optional[Any]:
        # _gather_4: expr _loop0_5
        mark = self._mark()
        if (
            (elem := self.expr())
            is not None
            and
            (seq := self._loop0_5())
            is not None
        ):
            return [elem] + seq;
        self._reset(mark)
        return None;

    @memoize
    def _loop1_6(self) -> Optional[Any]:
        # _loop1_6: ('or' conjunction)
        mark = self._mark()
        children = []
        while (
            (_tmp_11 := self._tmp_11())
        ):
            children.append(_tmp_11)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_7(self) -> Optional[Any]:
        # _loop1_7: ('and' inversion)
        mark = self._mark()
        children = []
        while (
            (_tmp_12 := self._tmp_12())
        ):
            children.append(_tmp_12)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_8(self) -> Optional[Any]:
        # _loop1_8: compare_op_bitwise_or_pair
        mark = self._mark()
        children = []
        while (
            (compare_op_bitwise_or_pair := self.compare_op_bitwise_or_pair())
        ):
            children.append(compare_op_bitwise_or_pair)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_9(self) -> Optional[Any]:
        # _tmp_9: expr ':' expr
        mark = self._mark()
        if (
            (k := self.expr())
            and
            (literal := self.expect(':'))
            and
            (v := self.expr())
        ):
            return [k, literal, v];
        self._reset(mark)
        return None;

    @memoize
    def _loop0_10(self) -> Optional[Any]:
        # _loop0_10: (',' expr ':' expr)
        mark = self._mark()
        children = []
        while (
            (_tmp_13 := self._tmp_13())
        ):
            children.append(_tmp_13)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_11(self) -> Optional[Any]:
        # _tmp_11: 'or' conjunction
        mark = self._mark()
        if (
            (self.expect('or'))
            and
            (c := self.conjunction())
        ):
            return c;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_12(self) -> Optional[Any]:
        # _tmp_12: 'and' inversion
        mark = self._mark()
        if (
            (self.expect('and'))
            and
            (c := self.inversion())
        ):
            return c;
        self._reset(mark)
        return None;

    @memoize
    def _tmp_13(self) -> Optional[Any]:
        # _tmp_13: ',' expr ':' expr
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (k := self.expr())
            and
            (literal_1 := self.expect(':'))
            and
            (v := self.expr())
        ):
            return [literal, k, literal_1, v];
        self._reset(mark)
        return None;

    KEYWORDS = ('False', 'None', 'True', 'and', 'async', 'await', 'class', 'def', 'delete', 'for', 'if', 'in', 'is', 'not', 'or', 'return', 'while')
    SOFT_KEYWORDS = ()


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(DSLParser)
