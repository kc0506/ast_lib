"""
This file is generated by scripts/gen_nodes.py, targeting Python 3.12

This module contains pattern matching nodes.
"""
# pyright: reportIncompatibleMethodOverride=false, reportUnnecessaryTypeIgnoreComment=false

from __future__ import annotations

import ast
import typing

# from pydantic import Field
# from pydantic.dataclasses import dataclass
from dataclasses import dataclass, field
from dataclasses import field as Field
from typing import (
    TYPE_CHECKING,
    Any,
    ClassVar,
    Generator,
    Generic,
    Iterable,
    Literal,
    Mapping,
    Protocol,
    Self,
    TypedDict,
    Unpack,
    cast,
    overload,
)

if TYPE_CHECKING:
    from .match_pattern import MatchResult, MatchTypeHint
from ast_lib.utils import parse_as_expr, parse_as_stmt

type _Identifier = str
type _Pattern = pattern
type _Slice = expr

type ASTPattern[T] = T | Wildcard | Capture[T] | Capture[ASTPattern[T]]

# class EmptyKwargs(Untype)


# ----------------------------------- Bases ---------------------------------- #


@dataclass(frozen=True)
class AST:
    # def __repr__(self) -> str:
    #     default_repr = super().__repr__()

    # def __hash__(self) -> int:
    #     return object.__hash__(self.fields)

    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    @property
    def _fields(self) -> tuple[str, ...]:
        return self._field_names

    @property
    def fields(self) -> Generator[tuple[str, Any]]:
        return iter_fields(self, self._fields)

    @property
    def field_dict(self) -> dict[str, Any]:
        return {k: v for k, v in self.fields}

    @property
    def child_fields(self) -> Generator[tuple[str, AST | list[AST]]]:
        return iter_fields(self, self._child_fields)

    @property
    def children(self) -> Generator[AST]:
        return iter_child_nodes(self)

    @property
    def ast_class(self) -> type[ast.AST]:
        return ast.__dict__[type(self).__name__]

    # if not TYPE_CHECKING:
    def replace(self, **kwargs) -> Self:
        cls = type(self)
        return cls(**self.field_dict, **kwargs)

    def _match[*T, K: dict](
        self: AST,
        target: ast.AST | str,
        *,
        assert_match: Literal[False] | Literal[True] = False,
        type_hint: MatchTypeHint[ast.AST, *T, K] | None = None,
    ) -> MatchResult[ast.AST, *T, K] | None:
        from .match_pattern import match_node

        if isinstance(target, str):
            if isinstance(self, expr):
                target = parse_as_expr(target)
            elif isinstance(self, stmt):
                target = parse_as_stmt(target)
            else:
                target = ast.parse(target)
        assert_match = cast(Literal[False], assert_match)
        res = match_node(
            self,
            target,
            assert_match=assert_match,
        )
        return cast(Any, res)

    if TYPE_CHECKING:
        match: Matchable[ast.AST] = field(init=False)
    else:
        match = _match


N = typing.TypeVar("N", bound=ast.AST, covariant=True)


# class Matchable[N: ast.AST](Protocol):
class Matchable(Protocol, Generic[N]):  # pyright: ignore[reportInvalidTypeVarUse]
    if TYPE_CHECKING:
        DEFAULT_MATCH_TYPE_HINT = cast(MatchTypeHint[N, int, dict], object())

    @overload
    def __call__[*T, K](
        self,
        target: ast.AST | str,
        *,
        assert_match: Literal[True],
        groups_hint: type[tuple[*T]] = tuple[Any, ...],
        kw_groups_hint: type[K] = Mapping[str, Any],
    ) -> MatchResult[N, *T, K]: ...

    @overload
    def __call__[*T, K](
        self,
        target: ast.AST | str,
        *,
        assert_match: Literal[False] = False,
        # type_hint: MatchTypeHint[N, *T, K] = DEFAULT_MATCH_TYPE_HINT,
        groups_hint: type[tuple[*T]] = tuple[Any, ...],
        kw_groups_hint: type[K] = Mapping[str, Any],
    ) -> MatchResult[N, *T, K] | None: ...


# ? Should it be hashable
AST.__hash__ = object.__hash__


def ast_repr(self: AST) -> str:
    output = repr(self)
    if len(output) >= 40:
        return f"{type(self).__name__}(...)"
    return output


# AST.__str__ = ast_repr


@dataclass(frozen=True)
class stmt(AST):
    pass


@dataclass(frozen=True)
class expr(AST):
    pass


# ------------------------------- Custom Bases ------------------------------- #


class _arguments_utils:
    @classmethod
    def make_empty(cls) -> arguments:
        cls = cast(type[arguments], cls)
        return cls(
            args=[],
            posonlyargs=[],
            vararg=None,
            kwonlyargs=[],
            kw_defaults=[],
            kwarg=None,
            defaults=[],
        )


# ---------------------------------- Custom ---------------------------------- #


# ? what is the difference between Wildcard and expr?
@dataclass(frozen=True)
class Wildcard(expr):
    pass


if TYPE_CHECKING:

    @dataclass(frozen=True)
    class WildcardId(AST, str):
        pass
else:

    @dataclass(frozen=True)
    class WildcardId(AST):
        pass


# TODO: Should T actually be contravariant?
@dataclass(frozen=True)
class Capture[T](AST):
    name: str | int
    pattern: ASTPattern[T]


@dataclass(frozen=True)
class Comment(stmt):
    value: ASTPattern[str] = Field(default_factory=Wildcard)


# ---------------------------------- Utils ---------------------------------- #


# Modified from ast.iter_fields
def iter_fields(node: AST, fields: Iterable[str]) -> Generator[tuple[str, Any]]:
    """
    Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields``
    that is present on *node*.
    """
    try:
        for node_field in fields:
            try:
                yield node_field, getattr(node, node_field)
            except AttributeError:
                pass
    except:
        # breakpoint()
        raise


# Copy of ast.iter_child_nodes
def iter_child_nodes(node: AST) -> Generator[AST]:
    """
    Yield all direct child nodes of *node*, that is, all fields that are nodes
    and all items of fields that are lists of nodes.
    """
    for _, node_field in iter_fields(node, node._fields):
        if isinstance(node_field, AST):
            yield node_field
        elif isinstance(node_field, list):
            for item in node_field:
                if isinstance(item, AST):
                    yield item


# ------------------------------ Generated Nodes ----------------------------- #

### Start


@dataclass(frozen=True)
class FunctionDef(stmt):
    name: ASTPattern[_Identifier] | WildcardId = Field(default_factory=WildcardId)
    args: ASTPattern[arguments] = Field(default_factory=Wildcard)
    body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]] = Field(
        default_factory=Wildcard
    )
    decorator_list: list[ASTPattern[expr]] | ASTPattern[list[expr]] = Field(
        default_factory=Wildcard
    )
    returns: ASTPattern[expr | None] = Field(default_factory=Wildcard)
    type_comment: ASTPattern[str | None] = Field(default_factory=Wildcard)
    type_params: list[ASTPattern[type_param]] | ASTPattern[list[type_param]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.FunctionDef] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = (
        "name",
        "args",
        "body",
        "decorator_list",
        "returns",
        "type_comment",
        "type_params",
    )
    _child_fields: ClassVar[tuple[str, ...]] = (
        "args",
        "body",
        "decorator_list",
        "returns",
        "type_params",
    )

    class FunctionDefArgs(TypedDict, total=False):
        name: ASTPattern[_Identifier] | WildcardId
        args: ASTPattern[arguments]
        body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]]
        decorator_list: list[ASTPattern[expr]] | ASTPattern[list[expr]]
        returns: ASTPattern[expr | None]
        type_comment: ASTPattern[str | None]
        type_params: list[ASTPattern[type_param]] | ASTPattern[list[type_param]]

    def replace(self, **kwargs: Unpack[FunctionDefArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class AsyncFunctionDef(stmt):
    name: ASTPattern[_Identifier] | WildcardId = Field(default_factory=WildcardId)
    args: ASTPattern[arguments] = Field(default_factory=Wildcard)
    body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]] = Field(
        default_factory=Wildcard
    )
    decorator_list: list[ASTPattern[expr]] | ASTPattern[list[expr]] = Field(
        default_factory=Wildcard
    )
    returns: ASTPattern[expr | None] = Field(default_factory=Wildcard)
    type_comment: ASTPattern[str | None] = Field(default_factory=Wildcard)
    type_params: list[ASTPattern[type_param]] | ASTPattern[list[type_param]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.AsyncFunctionDef] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = (
        "name",
        "args",
        "body",
        "decorator_list",
        "returns",
        "type_comment",
        "type_params",
    )
    _child_fields: ClassVar[tuple[str, ...]] = (
        "args",
        "body",
        "decorator_list",
        "returns",
        "type_params",
    )

    class AsyncFunctionDefArgs(TypedDict, total=False):
        name: ASTPattern[_Identifier] | WildcardId
        args: ASTPattern[arguments]
        body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]]
        decorator_list: list[ASTPattern[expr]] | ASTPattern[list[expr]]
        returns: ASTPattern[expr | None]
        type_comment: ASTPattern[str | None]
        type_params: list[ASTPattern[type_param]] | ASTPattern[list[type_param]]

    def replace(self, **kwargs: Unpack[AsyncFunctionDefArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class ClassDef(stmt):
    name: ASTPattern[_Identifier] | WildcardId = Field(default_factory=WildcardId)
    bases: list[ASTPattern[expr]] | ASTPattern[list[expr]] = Field(
        default_factory=Wildcard
    )
    keywords: list[ASTPattern[keyword]] | ASTPattern[list[keyword]] = Field(
        default_factory=Wildcard
    )
    body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]] = Field(
        default_factory=Wildcard
    )
    decorator_list: list[ASTPattern[expr]] | ASTPattern[list[expr]] = Field(
        default_factory=Wildcard
    )
    type_params: list[ASTPattern[type_param]] | ASTPattern[list[type_param]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.ClassDef] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = (
        "name",
        "bases",
        "keywords",
        "body",
        "decorator_list",
        "type_params",
    )
    _child_fields: ClassVar[tuple[str, ...]] = (
        "bases",
        "keywords",
        "body",
        "decorator_list",
        "type_params",
    )

    class ClassDefArgs(TypedDict, total=False):
        name: ASTPattern[_Identifier] | WildcardId
        bases: list[ASTPattern[expr]] | ASTPattern[list[expr]]
        keywords: list[ASTPattern[keyword]] | ASTPattern[list[keyword]]
        body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]]
        decorator_list: list[ASTPattern[expr]] | ASTPattern[list[expr]]
        type_params: list[ASTPattern[type_param]] | ASTPattern[list[type_param]]

    def replace(self, **kwargs: Unpack[ClassDefArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Return(stmt):
    value: ASTPattern[expr | None] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.Return] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("value",)
    _child_fields: ClassVar[tuple[str, ...]] = ("value",)

    class ReturnArgs(TypedDict, total=False):
        value: ASTPattern[expr | None]

    def replace(self, **kwargs: Unpack[ReturnArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Delete(stmt):
    targets: list[ASTPattern[expr]] | ASTPattern[list[expr]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.Delete] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("targets",)
    _child_fields: ClassVar[tuple[str, ...]] = ("targets",)

    class DeleteArgs(TypedDict, total=False):
        targets: list[ASTPattern[expr]] | ASTPattern[list[expr]]

    def replace(self, **kwargs: Unpack[DeleteArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Assign(stmt):
    targets: list[ASTPattern[expr]] | ASTPattern[list[expr]] = Field(
        default_factory=Wildcard
    )
    value: ASTPattern[expr] = Field(default_factory=Wildcard)
    type_comment: ASTPattern[str | None] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.Assign] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("targets", "value", "type_comment")
    _child_fields: ClassVar[tuple[str, ...]] = ("targets", "value")

    class AssignArgs(TypedDict, total=False):
        targets: list[ASTPattern[expr]] | ASTPattern[list[expr]]
        value: ASTPattern[expr]
        type_comment: ASTPattern[str | None]

    def replace(self, **kwargs: Unpack[AssignArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class TypeAlias(stmt):
    name: ASTPattern[Name] = Field(default_factory=Wildcard)
    type_params: list[ASTPattern[type_param]] | ASTPattern[list[type_param]] = Field(
        default_factory=Wildcard
    )
    value: ASTPattern[expr] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.TypeAlias] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("name", "type_params", "value")
    _child_fields: ClassVar[tuple[str, ...]] = ("name", "type_params", "value")

    class TypeAliasArgs(TypedDict, total=False):
        name: ASTPattern[Name]
        type_params: list[ASTPattern[type_param]] | ASTPattern[list[type_param]]
        value: ASTPattern[expr]

    def replace(self, **kwargs: Unpack[TypeAliasArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class AugAssign(stmt):
    target: ASTPattern[Name | Attribute | Subscript] = Field(default_factory=Wildcard)
    op: ASTPattern[operator] = Field(default_factory=Wildcard)
    value: ASTPattern[expr] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.AugAssign] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("target", "op", "value")
    _child_fields: ClassVar[tuple[str, ...]] = ("target", "op", "value")

    class AugAssignArgs(TypedDict, total=False):
        target: ASTPattern[Name | Attribute | Subscript]
        op: ASTPattern[operator]
        value: ASTPattern[expr]

    def replace(self, **kwargs: Unpack[AugAssignArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class AnnAssign(stmt):
    target: ASTPattern[Name | Attribute | Subscript] = Field(default_factory=Wildcard)
    annotation: ASTPattern[expr] = Field(default_factory=Wildcard)
    value: ASTPattern[expr | None] = Field(default_factory=Wildcard)
    simple: ASTPattern[int] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.AnnAssign] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = (
        "target",
        "annotation",
        "value",
        "simple",
    )
    _child_fields: ClassVar[tuple[str, ...]] = ("target", "annotation", "value")

    class AnnAssignArgs(TypedDict, total=False):
        target: ASTPattern[Name | Attribute | Subscript]
        annotation: ASTPattern[expr]
        value: ASTPattern[expr | None]
        simple: ASTPattern[int]

    def replace(self, **kwargs: Unpack[AnnAssignArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class For(stmt):
    target: ASTPattern[expr] = Field(default_factory=Wildcard)
    iter: ASTPattern[expr] = Field(default_factory=Wildcard)
    body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]] = Field(
        default_factory=Wildcard
    )
    orelse: list[ASTPattern[stmt]] | ASTPattern[list[stmt]] = Field(
        default_factory=Wildcard
    )
    type_comment: ASTPattern[str | None] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.For] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = (
        "target",
        "iter",
        "body",
        "orelse",
        "type_comment",
    )
    _child_fields: ClassVar[tuple[str, ...]] = ("target", "iter", "body", "orelse")

    class ForArgs(TypedDict, total=False):
        target: ASTPattern[expr]
        iter: ASTPattern[expr]
        body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]]
        orelse: list[ASTPattern[stmt]] | ASTPattern[list[stmt]]
        type_comment: ASTPattern[str | None]

    def replace(self, **kwargs: Unpack[ForArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class AsyncFor(stmt):
    target: ASTPattern[expr] = Field(default_factory=Wildcard)
    iter: ASTPattern[expr] = Field(default_factory=Wildcard)
    body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]] = Field(
        default_factory=Wildcard
    )
    orelse: list[ASTPattern[stmt]] | ASTPattern[list[stmt]] = Field(
        default_factory=Wildcard
    )
    type_comment: ASTPattern[str | None] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.AsyncFor] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = (
        "target",
        "iter",
        "body",
        "orelse",
        "type_comment",
    )
    _child_fields: ClassVar[tuple[str, ...]] = ("target", "iter", "body", "orelse")

    class AsyncForArgs(TypedDict, total=False):
        target: ASTPattern[expr]
        iter: ASTPattern[expr]
        body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]]
        orelse: list[ASTPattern[stmt]] | ASTPattern[list[stmt]]
        type_comment: ASTPattern[str | None]

    def replace(self, **kwargs: Unpack[AsyncForArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class While(stmt):
    test: ASTPattern[expr] = Field(default_factory=Wildcard)
    body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]] = Field(
        default_factory=Wildcard
    )
    orelse: list[ASTPattern[stmt]] | ASTPattern[list[stmt]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.While] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("test", "body", "orelse")
    _child_fields: ClassVar[tuple[str, ...]] = ("test", "body", "orelse")

    class WhileArgs(TypedDict, total=False):
        test: ASTPattern[expr]
        body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]]
        orelse: list[ASTPattern[stmt]] | ASTPattern[list[stmt]]

    def replace(self, **kwargs: Unpack[WhileArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class If(stmt):
    test: ASTPattern[expr] = Field(default_factory=Wildcard)
    body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]] = Field(
        default_factory=Wildcard
    )
    orelse: list[ASTPattern[stmt]] | ASTPattern[list[stmt]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.If] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("test", "body", "orelse")
    _child_fields: ClassVar[tuple[str, ...]] = ("test", "body", "orelse")

    class IfArgs(TypedDict, total=False):
        test: ASTPattern[expr]
        body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]]
        orelse: list[ASTPattern[stmt]] | ASTPattern[list[stmt]]

    def replace(self, **kwargs: Unpack[IfArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class With(stmt):
    items: list[ASTPattern[withitem]] | ASTPattern[list[withitem]] = Field(
        default_factory=Wildcard
    )
    body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]] = Field(
        default_factory=Wildcard
    )
    type_comment: ASTPattern[str | None] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.With] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("items", "body", "type_comment")
    _child_fields: ClassVar[tuple[str, ...]] = ("items", "body")

    class WithArgs(TypedDict, total=False):
        items: list[ASTPattern[withitem]] | ASTPattern[list[withitem]]
        body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]]
        type_comment: ASTPattern[str | None]

    def replace(self, **kwargs: Unpack[WithArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class AsyncWith(stmt):
    items: list[ASTPattern[withitem]] | ASTPattern[list[withitem]] = Field(
        default_factory=Wildcard
    )
    body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]] = Field(
        default_factory=Wildcard
    )
    type_comment: ASTPattern[str | None] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.AsyncWith] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("items", "body", "type_comment")
    _child_fields: ClassVar[tuple[str, ...]] = ("items", "body")

    class AsyncWithArgs(TypedDict, total=False):
        items: list[ASTPattern[withitem]] | ASTPattern[list[withitem]]
        body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]]
        type_comment: ASTPattern[str | None]

    def replace(self, **kwargs: Unpack[AsyncWithArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Match(stmt):
    subject: ASTPattern[expr] = Field(default_factory=Wildcard)
    cases: list[ASTPattern[match_case]] | ASTPattern[list[match_case]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.Match] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("subject", "cases")
    _child_fields: ClassVar[tuple[str, ...]] = ("subject", "cases")

    class MatchArgs(TypedDict, total=False):
        subject: ASTPattern[expr]
        cases: list[ASTPattern[match_case]] | ASTPattern[list[match_case]]

    def replace(self, **kwargs: Unpack[MatchArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Raise(stmt):
    exc: ASTPattern[expr | None] = Field(default_factory=Wildcard)
    cause: ASTPattern[expr | None] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.Raise] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("exc", "cause")
    _child_fields: ClassVar[tuple[str, ...]] = ("exc", "cause")

    class RaiseArgs(TypedDict, total=False):
        exc: ASTPattern[expr | None]
        cause: ASTPattern[expr | None]

    def replace(self, **kwargs: Unpack[RaiseArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Try(stmt):
    body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]] = Field(
        default_factory=Wildcard
    )
    handlers: list[ASTPattern[ExceptHandler]] | ASTPattern[list[ExceptHandler]] = Field(
        default_factory=Wildcard
    )
    orelse: list[ASTPattern[stmt]] | ASTPattern[list[stmt]] = Field(
        default_factory=Wildcard
    )
    finalbody: list[ASTPattern[stmt]] | ASTPattern[list[stmt]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.Try] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = (
        "body",
        "handlers",
        "orelse",
        "finalbody",
    )
    _child_fields: ClassVar[tuple[str, ...]] = (
        "body",
        "handlers",
        "orelse",
        "finalbody",
    )

    class TryArgs(TypedDict, total=False):
        body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]]
        handlers: list[ASTPattern[ExceptHandler]] | ASTPattern[list[ExceptHandler]]
        orelse: list[ASTPattern[stmt]] | ASTPattern[list[stmt]]
        finalbody: list[ASTPattern[stmt]] | ASTPattern[list[stmt]]

    def replace(self, **kwargs: Unpack[TryArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class TryStar(stmt):
    body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]] = Field(
        default_factory=Wildcard
    )
    handlers: list[ASTPattern[ExceptHandler]] | ASTPattern[list[ExceptHandler]] = Field(
        default_factory=Wildcard
    )
    orelse: list[ASTPattern[stmt]] | ASTPattern[list[stmt]] = Field(
        default_factory=Wildcard
    )
    finalbody: list[ASTPattern[stmt]] | ASTPattern[list[stmt]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.TryStar] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = (
        "body",
        "handlers",
        "orelse",
        "finalbody",
    )
    _child_fields: ClassVar[tuple[str, ...]] = (
        "body",
        "handlers",
        "orelse",
        "finalbody",
    )

    class TryStarArgs(TypedDict, total=False):
        body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]]
        handlers: list[ASTPattern[ExceptHandler]] | ASTPattern[list[ExceptHandler]]
        orelse: list[ASTPattern[stmt]] | ASTPattern[list[stmt]]
        finalbody: list[ASTPattern[stmt]] | ASTPattern[list[stmt]]

    def replace(self, **kwargs: Unpack[TryStarArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Assert(stmt):
    test: ASTPattern[expr] = Field(default_factory=Wildcard)
    msg: ASTPattern[expr | None] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.Assert] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("test", "msg")
    _child_fields: ClassVar[tuple[str, ...]] = ("test", "msg")

    class AssertArgs(TypedDict, total=False):
        test: ASTPattern[expr]
        msg: ASTPattern[expr | None]

    def replace(self, **kwargs: Unpack[AssertArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Import(stmt):
    names: list[ASTPattern[alias]] | ASTPattern[list[alias]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.Import] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("names",)
    _child_fields: ClassVar[tuple[str, ...]] = ("names",)

    class ImportArgs(TypedDict, total=False):
        names: list[ASTPattern[alias]] | ASTPattern[list[alias]]

    def replace(self, **kwargs: Unpack[ImportArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class ImportFrom(stmt):
    module: ASTPattern[str | None] = Field(default_factory=Wildcard)
    names: list[ASTPattern[alias]] | ASTPattern[list[alias]] = Field(
        default_factory=Wildcard
    )
    level: ASTPattern[int] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.ImportFrom] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("module", "names", "level")
    _child_fields: ClassVar[tuple[str, ...]] = ("names",)

    class ImportFromArgs(TypedDict, total=False):
        module: ASTPattern[str | None]
        names: list[ASTPattern[alias]] | ASTPattern[list[alias]]
        level: ASTPattern[int]

    def replace(self, **kwargs: Unpack[ImportFromArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Global(stmt):
    names: list[ASTPattern[_Identifier]] | ASTPattern[list[_Identifier]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.Global] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("names",)
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class GlobalArgs(TypedDict, total=False):
        names: list[ASTPattern[_Identifier]] | ASTPattern[list[_Identifier]]

    def replace(self, **kwargs: Unpack[GlobalArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Nonlocal(stmt):
    names: list[ASTPattern[_Identifier]] | ASTPattern[list[_Identifier]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.Nonlocal] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("names",)
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class NonlocalArgs(TypedDict, total=False):
        names: list[ASTPattern[_Identifier]] | ASTPattern[list[_Identifier]]

    def replace(self, **kwargs: Unpack[NonlocalArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Expr(stmt):
    value: ASTPattern[expr] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.Expr] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("value",)
    _child_fields: ClassVar[tuple[str, ...]] = ("value",)

    class ExprArgs(TypedDict, total=False):
        value: ASTPattern[expr]

    def replace(self, **kwargs: Unpack[ExprArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Pass(stmt):
    if TYPE_CHECKING:
        match: Matchable[ast.Pass] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class PassArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[PassArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Break(stmt):
    if TYPE_CHECKING:
        match: Matchable[ast.Break] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class BreakArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[BreakArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Continue(stmt):
    if TYPE_CHECKING:
        match: Matchable[ast.Continue] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class ContinueArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[ContinueArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class BoolOp(expr):
    op: ASTPattern[boolop] = Field(default_factory=Wildcard)
    values: list[ASTPattern[expr]] | ASTPattern[list[expr]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.BoolOp] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("op", "values")
    _child_fields: ClassVar[tuple[str, ...]] = ("op", "values")

    class BoolOpArgs(TypedDict, total=False):
        op: ASTPattern[boolop]
        values: list[ASTPattern[expr]] | ASTPattern[list[expr]]

    def replace(self, **kwargs: Unpack[BoolOpArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class NamedExpr(expr):
    target: ASTPattern[Name] = Field(default_factory=Wildcard)
    value: ASTPattern[expr] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.NamedExpr] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("target", "value")
    _child_fields: ClassVar[tuple[str, ...]] = ("target", "value")

    class NamedExprArgs(TypedDict, total=False):
        target: ASTPattern[Name]
        value: ASTPattern[expr]

    def replace(self, **kwargs: Unpack[NamedExprArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class BinOp(expr):
    left: ASTPattern[expr] = Field(default_factory=Wildcard)
    op: ASTPattern[operator] = Field(default_factory=Wildcard)
    right: ASTPattern[expr] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.BinOp] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("left", "op", "right")
    _child_fields: ClassVar[tuple[str, ...]] = ("left", "op", "right")

    class BinOpArgs(TypedDict, total=False):
        left: ASTPattern[expr]
        op: ASTPattern[operator]
        right: ASTPattern[expr]

    def replace(self, **kwargs: Unpack[BinOpArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class UnaryOp(expr):
    op: ASTPattern[unaryop] = Field(default_factory=Wildcard)
    operand: ASTPattern[expr] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.UnaryOp] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("op", "operand")
    _child_fields: ClassVar[tuple[str, ...]] = ("op", "operand")

    class UnaryOpArgs(TypedDict, total=False):
        op: ASTPattern[unaryop]
        operand: ASTPattern[expr]

    def replace(self, **kwargs: Unpack[UnaryOpArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Lambda(expr):
    args: ASTPattern[arguments] = Field(default_factory=Wildcard)
    body: ASTPattern[expr] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.Lambda] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("args", "body")
    _child_fields: ClassVar[tuple[str, ...]] = ("args", "body")

    class LambdaArgs(TypedDict, total=False):
        args: ASTPattern[arguments]
        body: ASTPattern[expr]

    def replace(self, **kwargs: Unpack[LambdaArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class IfExp(expr):
    test: ASTPattern[expr] = Field(default_factory=Wildcard)
    body: ASTPattern[expr] = Field(default_factory=Wildcard)
    orelse: ASTPattern[expr] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.IfExp] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("test", "body", "orelse")
    _child_fields: ClassVar[tuple[str, ...]] = ("test", "body", "orelse")

    class IfExpArgs(TypedDict, total=False):
        test: ASTPattern[expr]
        body: ASTPattern[expr]
        orelse: ASTPattern[expr]

    def replace(self, **kwargs: Unpack[IfExpArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Dict(expr):
    keys: list[ASTPattern[expr | None]] | ASTPattern[list[expr | None]] = Field(
        default_factory=Wildcard
    )
    values: list[ASTPattern[expr]] | ASTPattern[list[expr]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.Dict] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("keys", "values")
    _child_fields: ClassVar[tuple[str, ...]] = ("values",)

    class DictArgs(TypedDict, total=False):
        keys: list[ASTPattern[expr | None]] | ASTPattern[list[expr | None]]
        values: list[ASTPattern[expr]] | ASTPattern[list[expr]]

    def replace(self, **kwargs: Unpack[DictArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Set(expr):
    elts: list[ASTPattern[expr]] | ASTPattern[list[expr]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.Set] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("elts",)
    _child_fields: ClassVar[tuple[str, ...]] = ("elts",)

    class SetArgs(TypedDict, total=False):
        elts: list[ASTPattern[expr]] | ASTPattern[list[expr]]

    def replace(self, **kwargs: Unpack[SetArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class ListComp(expr):
    elt: ASTPattern[expr] = Field(default_factory=Wildcard)
    generators: list[ASTPattern[comprehension]] | ASTPattern[list[comprehension]] = (
        Field(default_factory=Wildcard)
    )
    if TYPE_CHECKING:
        match: Matchable[ast.ListComp] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("elt", "generators")
    _child_fields: ClassVar[tuple[str, ...]] = ("elt", "generators")

    class ListCompArgs(TypedDict, total=False):
        elt: ASTPattern[expr]
        generators: list[ASTPattern[comprehension]] | ASTPattern[list[comprehension]]

    def replace(self, **kwargs: Unpack[ListCompArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class SetComp(expr):
    elt: ASTPattern[expr] = Field(default_factory=Wildcard)
    generators: list[ASTPattern[comprehension]] | ASTPattern[list[comprehension]] = (
        Field(default_factory=Wildcard)
    )
    if TYPE_CHECKING:
        match: Matchable[ast.SetComp] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("elt", "generators")
    _child_fields: ClassVar[tuple[str, ...]] = ("elt", "generators")

    class SetCompArgs(TypedDict, total=False):
        elt: ASTPattern[expr]
        generators: list[ASTPattern[comprehension]] | ASTPattern[list[comprehension]]

    def replace(self, **kwargs: Unpack[SetCompArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class DictComp(expr):
    key: ASTPattern[expr] = Field(default_factory=Wildcard)
    value: ASTPattern[expr] = Field(default_factory=Wildcard)
    generators: list[ASTPattern[comprehension]] | ASTPattern[list[comprehension]] = (
        Field(default_factory=Wildcard)
    )
    if TYPE_CHECKING:
        match: Matchable[ast.DictComp] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("key", "value", "generators")
    _child_fields: ClassVar[tuple[str, ...]] = ("key", "value", "generators")

    class DictCompArgs(TypedDict, total=False):
        key: ASTPattern[expr]
        value: ASTPattern[expr]
        generators: list[ASTPattern[comprehension]] | ASTPattern[list[comprehension]]

    def replace(self, **kwargs: Unpack[DictCompArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class GeneratorExp(expr):
    elt: ASTPattern[expr] = Field(default_factory=Wildcard)
    generators: list[ASTPattern[comprehension]] | ASTPattern[list[comprehension]] = (
        Field(default_factory=Wildcard)
    )
    if TYPE_CHECKING:
        match: Matchable[ast.GeneratorExp] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("elt", "generators")
    _child_fields: ClassVar[tuple[str, ...]] = ("elt", "generators")

    class GeneratorExpArgs(TypedDict, total=False):
        elt: ASTPattern[expr]
        generators: list[ASTPattern[comprehension]] | ASTPattern[list[comprehension]]

    def replace(self, **kwargs: Unpack[GeneratorExpArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Await(expr):
    value: ASTPattern[expr] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.Await] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("value",)
    _child_fields: ClassVar[tuple[str, ...]] = ("value",)

    class AwaitArgs(TypedDict, total=False):
        value: ASTPattern[expr]

    def replace(self, **kwargs: Unpack[AwaitArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Yield(expr):
    value: ASTPattern[expr | None] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.Yield] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("value",)
    _child_fields: ClassVar[tuple[str, ...]] = ("value",)

    class YieldArgs(TypedDict, total=False):
        value: ASTPattern[expr | None]

    def replace(self, **kwargs: Unpack[YieldArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class YieldFrom(expr):
    value: ASTPattern[expr] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.YieldFrom] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("value",)
    _child_fields: ClassVar[tuple[str, ...]] = ("value",)

    class YieldFromArgs(TypedDict, total=False):
        value: ASTPattern[expr]

    def replace(self, **kwargs: Unpack[YieldFromArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Compare(expr):
    left: ASTPattern[expr] = Field(default_factory=Wildcard)
    ops: list[ASTPattern[cmpop]] | ASTPattern[list[cmpop]] = Field(
        default_factory=Wildcard
    )
    comparators: list[ASTPattern[expr]] | ASTPattern[list[expr]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.Compare] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("left", "ops", "comparators")
    _child_fields: ClassVar[tuple[str, ...]] = ("left", "ops", "comparators")

    class CompareArgs(TypedDict, total=False):
        left: ASTPattern[expr]
        ops: list[ASTPattern[cmpop]] | ASTPattern[list[cmpop]]
        comparators: list[ASTPattern[expr]] | ASTPattern[list[expr]]

    def replace(self, **kwargs: Unpack[CompareArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Call(expr):
    func: ASTPattern[expr] = Field(default_factory=Wildcard)
    args: list[ASTPattern[expr]] | ASTPattern[list[expr]] = Field(
        default_factory=Wildcard
    )
    keywords: list[ASTPattern[keyword]] | ASTPattern[list[keyword]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.Call] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("func", "args", "keywords")
    _child_fields: ClassVar[tuple[str, ...]] = ("func", "args", "keywords")

    class CallArgs(TypedDict, total=False):
        func: ASTPattern[expr]
        args: list[ASTPattern[expr]] | ASTPattern[list[expr]]
        keywords: list[ASTPattern[keyword]] | ASTPattern[list[keyword]]

    def replace(self, **kwargs: Unpack[CallArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class FormattedValue(expr):
    value: ASTPattern[expr] = Field(default_factory=Wildcard)
    conversion: ASTPattern[int] = Field(default_factory=Wildcard)
    format_spec: ASTPattern[expr | None] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.FormattedValue] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("value", "conversion", "format_spec")
    _child_fields: ClassVar[tuple[str, ...]] = ("value", "format_spec")

    class FormattedValueArgs(TypedDict, total=False):
        value: ASTPattern[expr]
        conversion: ASTPattern[int]
        format_spec: ASTPattern[expr | None]

    def replace(self, **kwargs: Unpack[FormattedValueArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class JoinedStr(expr):
    values: list[ASTPattern[expr]] | ASTPattern[list[expr]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.JoinedStr] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("values",)
    _child_fields: ClassVar[tuple[str, ...]] = ("values",)

    class JoinedStrArgs(TypedDict, total=False):
        values: list[ASTPattern[expr]] | ASTPattern[list[expr]]

    def replace(self, **kwargs: Unpack[JoinedStrArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Constant(expr):
    value: ASTPattern[Any] = Field(default_factory=Wildcard)
    kind: ASTPattern[str | None] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.Constant] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("value", "kind")
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class ConstantArgs(TypedDict, total=False):
        value: ASTPattern[Any]
        kind: ASTPattern[str | None]

    def replace(self, **kwargs: Unpack[ConstantArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Attribute(expr):
    value: ASTPattern[expr] = Field(default_factory=Wildcard)
    attr: ASTPattern[_Identifier] | WildcardId = Field(default_factory=WildcardId)
    ctx: ASTPattern[expr_context] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.Attribute] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("value", "attr", "ctx")
    _child_fields: ClassVar[tuple[str, ...]] = ("value", "ctx")

    class AttributeArgs(TypedDict, total=False):
        value: ASTPattern[expr]
        attr: ASTPattern[_Identifier] | WildcardId
        ctx: ASTPattern[expr_context]

    def replace(self, **kwargs: Unpack[AttributeArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Subscript(expr):
    value: ASTPattern[expr] = Field(default_factory=Wildcard)
    slice: ASTPattern[_Slice] = Field(default_factory=Wildcard)
    ctx: ASTPattern[expr_context] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.Subscript] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("value", "slice", "ctx")
    _child_fields: ClassVar[tuple[str, ...]] = ("value", "slice", "ctx")

    class SubscriptArgs(TypedDict, total=False):
        value: ASTPattern[expr]
        slice: ASTPattern[_Slice]
        ctx: ASTPattern[expr_context]

    def replace(self, **kwargs: Unpack[SubscriptArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Starred(expr):
    value: ASTPattern[expr] = Field(default_factory=Wildcard)
    ctx: ASTPattern[expr_context] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.Starred] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("value", "ctx")
    _child_fields: ClassVar[tuple[str, ...]] = ("value", "ctx")

    class StarredArgs(TypedDict, total=False):
        value: ASTPattern[expr]
        ctx: ASTPattern[expr_context]

    def replace(self, **kwargs: Unpack[StarredArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Name(expr):
    id: ASTPattern[_Identifier] | WildcardId = Field(default_factory=WildcardId)
    ctx: ASTPattern[expr_context] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.Name] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("id", "ctx")
    _child_fields: ClassVar[tuple[str, ...]] = ("ctx",)

    class NameArgs(TypedDict, total=False):
        id: ASTPattern[_Identifier] | WildcardId
        ctx: ASTPattern[expr_context]

    def replace(self, **kwargs: Unpack[NameArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class List(expr):
    elts: list[ASTPattern[expr]] | ASTPattern[list[expr]] = Field(
        default_factory=Wildcard
    )
    ctx: ASTPattern[expr_context] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.List] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("elts", "ctx")
    _child_fields: ClassVar[tuple[str, ...]] = ("elts", "ctx")

    class ListArgs(TypedDict, total=False):
        elts: list[ASTPattern[expr]] | ASTPattern[list[expr]]
        ctx: ASTPattern[expr_context]

    def replace(self, **kwargs: Unpack[ListArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Tuple(expr):
    elts: list[ASTPattern[expr]] | ASTPattern[list[expr]] = Field(
        default_factory=Wildcard
    )
    ctx: ASTPattern[expr_context] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.Tuple] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("elts", "ctx")
    _child_fields: ClassVar[tuple[str, ...]] = ("elts", "ctx")

    class TupleArgs(TypedDict, total=False):
        elts: list[ASTPattern[expr]] | ASTPattern[list[expr]]
        ctx: ASTPattern[expr_context]

    def replace(self, **kwargs: Unpack[TupleArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class slice(AST):
    if TYPE_CHECKING:
        match: Matchable[ast.slice] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class sliceArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[sliceArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class ExtSlice(slice):
    dims: list[ASTPattern[slice]] | ASTPattern[list[slice]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.ExtSlice] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ("dims",)

    class ExtSliceArgs(TypedDict, total=False):
        dims: list[ASTPattern[slice]] | ASTPattern[list[slice]]

    def replace(self, **kwargs: Unpack[ExtSliceArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Index(slice):
    value: ASTPattern[expr] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.Index] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ("value",)

    class IndexArgs(TypedDict, total=False):
        value: ASTPattern[expr]

    def replace(self, **kwargs: Unpack[IndexArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class expr_context(AST):
    if TYPE_CHECKING:
        match: Matchable[ast.expr_context] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class expr_contextArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[expr_contextArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class AugLoad(expr_context):
    if TYPE_CHECKING:
        match: Matchable[ast.AugLoad] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class AugLoadArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[AugLoadArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class AugStore(expr_context):
    if TYPE_CHECKING:
        match: Matchable[ast.AugStore] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class AugStoreArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[AugStoreArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Param(expr_context):
    if TYPE_CHECKING:
        match: Matchable[ast.Param] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class ParamArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[ParamArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Load(expr_context):
    if TYPE_CHECKING:
        match: Matchable[ast.Load] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class LoadArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[LoadArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Store(expr_context):
    if TYPE_CHECKING:
        match: Matchable[ast.Store] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class StoreArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[StoreArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Del(expr_context):
    if TYPE_CHECKING:
        match: Matchable[ast.Del] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class DelArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[DelArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class boolop(AST):
    if TYPE_CHECKING:
        match: Matchable[ast.boolop] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class boolopArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[boolopArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class And(boolop):
    if TYPE_CHECKING:
        match: Matchable[ast.And] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class AndArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[AndArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Or(boolop):
    if TYPE_CHECKING:
        match: Matchable[ast.Or] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class OrArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[OrArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class operator(AST):
    if TYPE_CHECKING:
        match: Matchable[ast.operator] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class operatorArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[operatorArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Add(operator):
    if TYPE_CHECKING:
        match: Matchable[ast.Add] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class AddArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[AddArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Sub(operator):
    if TYPE_CHECKING:
        match: Matchable[ast.Sub] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class SubArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[SubArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Mult(operator):
    if TYPE_CHECKING:
        match: Matchable[ast.Mult] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class MultArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[MultArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class MatMult(operator):
    if TYPE_CHECKING:
        match: Matchable[ast.MatMult] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class MatMultArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[MatMultArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Div(operator):
    if TYPE_CHECKING:
        match: Matchable[ast.Div] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class DivArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[DivArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Mod(operator):
    if TYPE_CHECKING:
        match: Matchable[ast.Mod] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class ModArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[ModArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Pow(operator):
    if TYPE_CHECKING:
        match: Matchable[ast.Pow] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class PowArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[PowArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class LShift(operator):
    if TYPE_CHECKING:
        match: Matchable[ast.LShift] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class LShiftArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[LShiftArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class RShift(operator):
    if TYPE_CHECKING:
        match: Matchable[ast.RShift] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class RShiftArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[RShiftArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class BitOr(operator):
    if TYPE_CHECKING:
        match: Matchable[ast.BitOr] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class BitOrArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[BitOrArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class BitXor(operator):
    if TYPE_CHECKING:
        match: Matchable[ast.BitXor] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class BitXorArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[BitXorArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class BitAnd(operator):
    if TYPE_CHECKING:
        match: Matchable[ast.BitAnd] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class BitAndArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[BitAndArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class FloorDiv(operator):
    if TYPE_CHECKING:
        match: Matchable[ast.FloorDiv] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class FloorDivArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[FloorDivArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class unaryop(AST):
    if TYPE_CHECKING:
        match: Matchable[ast.unaryop] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class unaryopArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[unaryopArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Invert(unaryop):
    if TYPE_CHECKING:
        match: Matchable[ast.Invert] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class InvertArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[InvertArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Not(unaryop):
    if TYPE_CHECKING:
        match: Matchable[ast.Not] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class NotArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[NotArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class UAdd(unaryop):
    if TYPE_CHECKING:
        match: Matchable[ast.UAdd] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class UAddArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[UAddArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class USub(unaryop):
    if TYPE_CHECKING:
        match: Matchable[ast.USub] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class USubArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[USubArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class cmpop(AST):
    if TYPE_CHECKING:
        match: Matchable[ast.cmpop] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class cmpopArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[cmpopArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Eq(cmpop):
    if TYPE_CHECKING:
        match: Matchable[ast.Eq] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class EqArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[EqArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class NotEq(cmpop):
    if TYPE_CHECKING:
        match: Matchable[ast.NotEq] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class NotEqArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[NotEqArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Lt(cmpop):
    if TYPE_CHECKING:
        match: Matchable[ast.Lt] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class LtArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[LtArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class LtE(cmpop):
    if TYPE_CHECKING:
        match: Matchable[ast.LtE] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class LtEArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[LtEArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Gt(cmpop):
    if TYPE_CHECKING:
        match: Matchable[ast.Gt] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class GtArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[GtArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class GtE(cmpop):
    if TYPE_CHECKING:
        match: Matchable[ast.GtE] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class GtEArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[GtEArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class Is(cmpop):
    if TYPE_CHECKING:
        match: Matchable[ast.Is] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class IsArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[IsArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class IsNot(cmpop):
    if TYPE_CHECKING:
        match: Matchable[ast.IsNot] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class IsNotArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[IsNotArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class In(cmpop):
    if TYPE_CHECKING:
        match: Matchable[ast.In] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class InArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[InArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class NotIn(cmpop):
    if TYPE_CHECKING:
        match: Matchable[ast.NotIn] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class NotInArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[NotInArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class comprehension(AST):
    target: ASTPattern[expr] = Field(default_factory=Wildcard)
    iter: ASTPattern[expr] = Field(default_factory=Wildcard)
    ifs: list[ASTPattern[expr]] | ASTPattern[list[expr]] = Field(
        default_factory=Wildcard
    )
    is_async: ASTPattern[int] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.comprehension] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("target", "iter", "ifs", "is_async")
    _child_fields: ClassVar[tuple[str, ...]] = ("target", "iter", "ifs")

    class comprehensionArgs(TypedDict, total=False):
        target: ASTPattern[expr]
        iter: ASTPattern[expr]
        ifs: list[ASTPattern[expr]] | ASTPattern[list[expr]]
        is_async: ASTPattern[int]

    def replace(self, **kwargs: Unpack[comprehensionArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class excepthandler(AST):
    lineno: ASTPattern[int] = Field(default_factory=Wildcard)
    col_offset: ASTPattern[int] = Field(default_factory=Wildcard)
    end_lineno: ASTPattern[int | None] = Field(default_factory=Wildcard)
    end_col_offset: ASTPattern[int | None] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.excepthandler] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class excepthandlerArgs(TypedDict, total=False):
        lineno: ASTPattern[int]
        col_offset: ASTPattern[int]
        end_lineno: ASTPattern[int | None]
        end_col_offset: ASTPattern[int | None]

    def replace(self, **kwargs: Unpack[excepthandlerArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class ExceptHandler(excepthandler):
    type: ASTPattern[expr | None] = Field(default_factory=Wildcard)
    name: ASTPattern[_Identifier | None] = Field(default_factory=Wildcard)
    body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.ExceptHandler] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("type", "name", "body")
    _child_fields: ClassVar[tuple[str, ...]] = ("type", "body")

    class ExceptHandlerArgs(TypedDict, total=False):
        type: ASTPattern[expr | None]
        name: ASTPattern[_Identifier | None]
        body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]]

    def replace(self, **kwargs: Unpack[ExceptHandlerArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class arguments(AST, _arguments_utils):
    posonlyargs: list[ASTPattern[arg]] | ASTPattern[list[arg]] = Field(
        default_factory=Wildcard
    )
    args: list[ASTPattern[arg]] | ASTPattern[list[arg]] = Field(
        default_factory=Wildcard
    )
    vararg: ASTPattern[arg | None] = Field(default_factory=Wildcard)
    kwonlyargs: list[ASTPattern[arg]] | ASTPattern[list[arg]] = Field(
        default_factory=Wildcard
    )
    kw_defaults: list[ASTPattern[expr | None]] | ASTPattern[list[expr | None]] = Field(
        default_factory=Wildcard
    )
    kwarg: ASTPattern[arg | None] = Field(default_factory=Wildcard)
    defaults: list[ASTPattern[expr]] | ASTPattern[list[expr]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.arguments] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = (
        "posonlyargs",
        "args",
        "vararg",
        "kwonlyargs",
        "kw_defaults",
        "kwarg",
        "defaults",
    )
    _child_fields: ClassVar[tuple[str, ...]] = (
        "posonlyargs",
        "args",
        "vararg",
        "kwonlyargs",
        "kwarg",
        "defaults",
    )

    class argumentsArgs(TypedDict, total=False):
        posonlyargs: list[ASTPattern[arg]] | ASTPattern[list[arg]]
        args: list[ASTPattern[arg]] | ASTPattern[list[arg]]
        vararg: ASTPattern[arg | None]
        kwonlyargs: list[ASTPattern[arg]] | ASTPattern[list[arg]]
        kw_defaults: list[ASTPattern[expr | None]] | ASTPattern[list[expr | None]]
        kwarg: ASTPattern[arg | None]
        defaults: list[ASTPattern[expr]] | ASTPattern[list[expr]]

    def replace(self, **kwargs: Unpack[argumentsArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class arg(AST):
    lineno: ASTPattern[int] = Field(default_factory=Wildcard)
    col_offset: ASTPattern[int] = Field(default_factory=Wildcard)
    end_lineno: ASTPattern[int | None] = Field(default_factory=Wildcard)
    end_col_offset: ASTPattern[int | None] = Field(default_factory=Wildcard)
    arg: ASTPattern[_Identifier] | WildcardId = Field(default_factory=WildcardId)
    annotation: ASTPattern[expr | None] = Field(default_factory=Wildcard)
    type_comment: ASTPattern[str | None] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.arg] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("arg", "annotation", "type_comment")
    _child_fields: ClassVar[tuple[str, ...]] = ("annotation",)

    class argArgs(TypedDict, total=False):
        lineno: ASTPattern[int]
        col_offset: ASTPattern[int]
        end_lineno: ASTPattern[int | None]
        end_col_offset: ASTPattern[int | None]
        arg: ASTPattern[_Identifier] | WildcardId
        annotation: ASTPattern[expr | None]
        type_comment: ASTPattern[str | None]

    def replace(self, **kwargs: Unpack[argArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class keyword(AST):
    lineno: ASTPattern[int] = Field(default_factory=Wildcard)
    col_offset: ASTPattern[int] = Field(default_factory=Wildcard)
    end_lineno: ASTPattern[int | None] = Field(default_factory=Wildcard)
    end_col_offset: ASTPattern[int | None] = Field(default_factory=Wildcard)
    arg: ASTPattern[_Identifier | None] = Field(default_factory=Wildcard)
    value: ASTPattern[expr] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.keyword] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("arg", "value")
    _child_fields: ClassVar[tuple[str, ...]] = ("value",)

    class keywordArgs(TypedDict, total=False):
        lineno: ASTPattern[int]
        col_offset: ASTPattern[int]
        end_lineno: ASTPattern[int | None]
        end_col_offset: ASTPattern[int | None]
        arg: ASTPattern[_Identifier | None]
        value: ASTPattern[expr]

    def replace(self, **kwargs: Unpack[keywordArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class alias(AST):
    lineno: ASTPattern[int] = Field(default_factory=Wildcard)
    col_offset: ASTPattern[int] = Field(default_factory=Wildcard)
    end_lineno: ASTPattern[int | None] = Field(default_factory=Wildcard)
    end_col_offset: ASTPattern[int | None] = Field(default_factory=Wildcard)
    name: ASTPattern[str] = Field(default_factory=Wildcard)
    asname: ASTPattern[_Identifier | None] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.alias] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("name", "asname")
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class aliasArgs(TypedDict, total=False):
        lineno: ASTPattern[int]
        col_offset: ASTPattern[int]
        end_lineno: ASTPattern[int | None]
        end_col_offset: ASTPattern[int | None]
        name: ASTPattern[str]
        asname: ASTPattern[_Identifier | None]

    def replace(self, **kwargs: Unpack[aliasArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class withitem(AST):
    context_expr: ASTPattern[expr] = Field(default_factory=Wildcard)
    optional_vars: ASTPattern[expr | None] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.withitem] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("context_expr", "optional_vars")
    _child_fields: ClassVar[tuple[str, ...]] = ("context_expr", "optional_vars")

    class withitemArgs(TypedDict, total=False):
        context_expr: ASTPattern[expr]
        optional_vars: ASTPattern[expr | None]

    def replace(self, **kwargs: Unpack[withitemArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class match_case(AST):
    pattern: ASTPattern[_Pattern] = Field(default_factory=Wildcard)
    guard: ASTPattern[expr | None] = Field(default_factory=Wildcard)
    body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.match_case] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("pattern", "guard", "body")
    _child_fields: ClassVar[tuple[str, ...]] = ("guard", "body")

    class match_caseArgs(TypedDict, total=False):
        pattern: ASTPattern[_Pattern]
        guard: ASTPattern[expr | None]
        body: list[ASTPattern[stmt]] | ASTPattern[list[stmt]]

    def replace(self, **kwargs: Unpack[match_caseArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class pattern(AST):
    lineno: ASTPattern[int] = Field(default_factory=Wildcard)
    col_offset: ASTPattern[int] = Field(default_factory=Wildcard)
    end_lineno: ASTPattern[int] = Field(default_factory=Wildcard)
    end_col_offset: ASTPattern[int] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.pattern] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class patternArgs(TypedDict, total=False):
        lineno: ASTPattern[int]
        col_offset: ASTPattern[int]
        end_lineno: ASTPattern[int]
        end_col_offset: ASTPattern[int]

    def replace(self, **kwargs: Unpack[patternArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class MatchValue(pattern):
    value: ASTPattern[expr] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.MatchValue] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("value",)
    _child_fields: ClassVar[tuple[str, ...]] = ("value",)

    class MatchValueArgs(TypedDict, total=False):
        value: ASTPattern[expr]

    def replace(self, **kwargs: Unpack[MatchValueArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class MatchSingleton(pattern):
    value: ASTPattern[Literal[True, False] | None] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.MatchSingleton] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("value",)
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class MatchSingletonArgs(TypedDict, total=False):
        value: ASTPattern[Literal[True, False] | None]

    def replace(self, **kwargs: Unpack[MatchSingletonArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class MatchSequence(pattern):
    patterns: list[ASTPattern[pattern]] | ASTPattern[list[pattern]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.MatchSequence] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("patterns",)
    _child_fields: ClassVar[tuple[str, ...]] = ("patterns",)

    class MatchSequenceArgs(TypedDict, total=False):
        patterns: list[ASTPattern[pattern]] | ASTPattern[list[pattern]]

    def replace(self, **kwargs: Unpack[MatchSequenceArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class MatchMapping(pattern):
    keys: list[ASTPattern[expr]] | ASTPattern[list[expr]] = Field(
        default_factory=Wildcard
    )
    patterns: list[ASTPattern[pattern]] | ASTPattern[list[pattern]] = Field(
        default_factory=Wildcard
    )
    rest: ASTPattern[_Identifier | None] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.MatchMapping] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("keys", "patterns", "rest")
    _child_fields: ClassVar[tuple[str, ...]] = ("keys", "patterns")

    class MatchMappingArgs(TypedDict, total=False):
        keys: list[ASTPattern[expr]] | ASTPattern[list[expr]]
        patterns: list[ASTPattern[pattern]] | ASTPattern[list[pattern]]
        rest: ASTPattern[_Identifier | None]

    def replace(self, **kwargs: Unpack[MatchMappingArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class MatchClass(pattern):
    cls: ASTPattern[expr] = Field(default_factory=Wildcard)
    patterns: list[ASTPattern[pattern]] | ASTPattern[list[pattern]] = Field(
        default_factory=Wildcard
    )
    kwd_attrs: list[ASTPattern[_Identifier]] | ASTPattern[list[_Identifier]] = Field(
        default_factory=Wildcard
    )
    kwd_patterns: list[ASTPattern[pattern]] | ASTPattern[list[pattern]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.MatchClass] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = (
        "cls",
        "patterns",
        "kwd_attrs",
        "kwd_patterns",
    )
    _child_fields: ClassVar[tuple[str, ...]] = ("cls", "patterns", "kwd_patterns")

    class MatchClassArgs(TypedDict, total=False):
        cls: ASTPattern[expr]
        patterns: list[ASTPattern[pattern]] | ASTPattern[list[pattern]]
        kwd_attrs: list[ASTPattern[_Identifier]] | ASTPattern[list[_Identifier]]
        kwd_patterns: list[ASTPattern[pattern]] | ASTPattern[list[pattern]]

    def replace(self, **kwargs: Unpack[MatchClassArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class MatchStar(pattern):
    name: ASTPattern[_Identifier | None] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.MatchStar] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("name",)
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class MatchStarArgs(TypedDict, total=False):
        name: ASTPattern[_Identifier | None]

    def replace(self, **kwargs: Unpack[MatchStarArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class MatchAs(pattern):
    pattern: ASTPattern[_Pattern | None] = Field(default_factory=Wildcard)
    name: ASTPattern[_Identifier | None] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.MatchAs] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("pattern", "name")
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class MatchAsArgs(TypedDict, total=False):
        pattern: ASTPattern[_Pattern | None]
        name: ASTPattern[_Identifier | None]

    def replace(self, **kwargs: Unpack[MatchAsArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class MatchOr(pattern):
    patterns: list[ASTPattern[pattern]] | ASTPattern[list[pattern]] = Field(
        default_factory=Wildcard
    )
    if TYPE_CHECKING:
        match: Matchable[ast.MatchOr] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("patterns",)
    _child_fields: ClassVar[tuple[str, ...]] = ("patterns",)

    class MatchOrArgs(TypedDict, total=False):
        patterns: list[ASTPattern[pattern]] | ASTPattern[list[pattern]]

    def replace(self, **kwargs: Unpack[MatchOrArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class type_ignore(AST):
    if TYPE_CHECKING:
        match: Matchable[ast.type_ignore] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class type_ignoreArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[type_ignoreArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class TypeIgnore(type_ignore):
    lineno: ASTPattern[int] = Field(default_factory=Wildcard)
    tag: ASTPattern[str] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.TypeIgnore] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("lineno", "tag")
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class TypeIgnoreArgs(TypedDict, total=False):
        lineno: ASTPattern[int]
        tag: ASTPattern[str]

    def replace(self, **kwargs: Unpack[TypeIgnoreArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class type_param(AST):
    if TYPE_CHECKING:
        match: Matchable[ast.type_param] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ()
    _child_fields: ClassVar[tuple[str, ...]] = ()

    class type_paramArgs(TypedDict, total=False):
        pass

    def replace(self, **kwargs: Unpack[type_paramArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class TypeVar(type_param):
    name: ASTPattern[_Identifier] | WildcardId = Field(default_factory=WildcardId)
    bound: ASTPattern[expr | None] = Field(default_factory=Wildcard)
    default_value: ASTPattern[expr | None] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.TypeVar] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("name", "bound")
    _child_fields: ClassVar[tuple[str, ...]] = ("bound", "default_value")

    class TypeVarArgs(TypedDict, total=False):
        name: ASTPattern[_Identifier] | WildcardId
        bound: ASTPattern[expr | None]
        default_value: ASTPattern[expr | None]

    def replace(self, **kwargs: Unpack[TypeVarArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class ParamSpec(type_param):
    name: ASTPattern[_Identifier] | WildcardId = Field(default_factory=WildcardId)
    default_value: ASTPattern[expr | None] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.ParamSpec] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("name",)
    _child_fields: ClassVar[tuple[str, ...]] = ("default_value",)

    class ParamSpecArgs(TypedDict, total=False):
        name: ASTPattern[_Identifier] | WildcardId
        default_value: ASTPattern[expr | None]

    def replace(self, **kwargs: Unpack[ParamSpecArgs]) -> Self:
        return super().replace(**kwargs)


@dataclass(frozen=True)
class TypeVarTuple(type_param):
    name: ASTPattern[_Identifier] | WildcardId = Field(default_factory=WildcardId)
    default_value: ASTPattern[expr | None] = Field(default_factory=Wildcard)
    if TYPE_CHECKING:
        match: Matchable[ast.TypeVarTuple] = field(init=False)
    _field_names: ClassVar[tuple[str, ...]] = ("name",)
    _child_fields: ClassVar[tuple[str, ...]] = ("default_value",)

    class TypeVarTupleArgs(TypedDict, total=False):
        name: ASTPattern[_Identifier] | WildcardId
        default_value: ASTPattern[expr | None]

    def replace(self, **kwargs: Unpack[TypeVarTupleArgs]) -> Self:
        return super().replace(**kwargs)


__all__ = (
    "FunctionDef",
    "AsyncFunctionDef",
    "ClassDef",
    "Return",
    "Delete",
    "Assign",
    "TypeAlias",
    "AugAssign",
    "AnnAssign",
    "For",
    "AsyncFor",
    "While",
    "If",
    "With",
    "AsyncWith",
    "Match",
    "Raise",
    "Try",
    "TryStar",
    "Assert",
    "Import",
    "ImportFrom",
    "Global",
    "Nonlocal",
    "Expr",
    "Pass",
    "Break",
    "Continue",
    "BoolOp",
    "NamedExpr",
    "BinOp",
    "UnaryOp",
    "Lambda",
    "IfExp",
    "Dict",
    "Set",
    "ListComp",
    "SetComp",
    "DictComp",
    "GeneratorExp",
    "Await",
    "Yield",
    "YieldFrom",
    "Compare",
    "Call",
    "FormattedValue",
    "JoinedStr",
    "Constant",
    "Attribute",
    "Subscript",
    "Starred",
    "Name",
    "List",
    "Tuple",
    "slice",
    "ExtSlice",
    "Index",
    "expr_context",
    "AugLoad",
    "AugStore",
    "Param",
    "Load",
    "Store",
    "Del",
    "boolop",
    "And",
    "Or",
    "operator",
    "Add",
    "Sub",
    "Mult",
    "MatMult",
    "Div",
    "Mod",
    "Pow",
    "LShift",
    "RShift",
    "BitOr",
    "BitXor",
    "BitAnd",
    "FloorDiv",
    "unaryop",
    "Invert",
    "Not",
    "UAdd",
    "USub",
    "cmpop",
    "Eq",
    "NotEq",
    "Lt",
    "LtE",
    "Gt",
    "GtE",
    "Is",
    "IsNot",
    "In",
    "NotIn",
    "comprehension",
    "excepthandler",
    "ExceptHandler",
    "arguments",
    "arg",
    "keyword",
    "alias",
    "withitem",
    "match_case",
    "pattern",
    "MatchValue",
    "MatchSingleton",
    "MatchSequence",
    "MatchMapping",
    "MatchClass",
    "MatchStar",
    "MatchAs",
    "MatchOr",
    "type_ignore",
    "TypeIgnore",
    "type_param",
    "TypeVar",
    "ParamSpec",
    "TypeVarTuple",
    "_Identifier",
    "_Pattern",
    "_Slice",
    "ASTPattern",
    "AST",
    "Matchable",
    "stmt",
    "expr",
    "_arguments_utils",
    "Wildcard",
    "WildcardId",
    "WildcardId",
    "Capture",
    "Comment",
)

### End
