# TODO: args
# TODO: $0
# TODO: invalid syntax message
# TODO: is this ambiguous? $a{}
# TODO: specify type (especially Constant)
# TODO? use different actions to generate test cases
# TODO: maybe support body
# TODO: maybe just use normal grammar parser
# ? Use _ for typing?
# $<>, $[], $()
# TODO: I forgot why cannot use ~ for wildcard id
# TODO: uop, op

@class"DSLParser"

@header"""\
#!/usr/bin/env python3.8
# @generated by pegen from {filename}
# pyright: reportUnusedVariable=false, reportUnusedImport=false, reportIncompatibleMethodOverride=false, reportUnusedParameter=false
# ruff: noqa: F401, F841, E703, F405, F403, F634

from __future__ import annotations


import ast
import sys
import tokenize

from typing import Any, Optional, TYPE_CHECKING, cast

from rich import print
from pegen.parser import memoize, memoize_left_rec, logger, Parser
"""


@subheader"""\
from functools import reduce, wraps
from .nodes import *

def wrap_start(fn):
    @wraps(fn)
    def wrapper(self, *args, **kwargs):
        ret = fn(self, *args, **kwargs)
        # if ret is not None:
            # print('start result:')
            # print(ret)
        return ret
    return wrapper

def wrap_stmt(fn):
    @wraps(fn)
    def wrapper(self, *args, **kwargs):
        lineno = self._tokenizer.peek().start[0]
        ret = fn(self, *args, **kwargs)
        # if ret is not None:
        #     print(f'line {lineno}:', ret)
        return ret
    return wrapper

def _reduce_chain(p, s):
    def reducer(acc, suffix):
        if suffix['type'] == 'Call':
            return Call(func=acc, args=suffix['args'])
        if suffix['type'] == 'Attribute':
            return Attribute(value=acc, attr=suffix['attr'])
        if suffix['type'] == 'Subscript':
            return Subscript(value=acc, slice=suffix['slice'])
        return acc
    
    return reduce(reducer, s, p)

def _make_dict(head, tail):
    return tuple(zip(*[head] + [(k, v) for _, k, __, v in tail]))

"""

start = stmts ENDMARKER { stmts }

stmts[list[stmt]] =
    s:stmt '\n' rest:stmts {[s, *rest]}     
    / s:stmt '\n' { [s] }
    / s:stmt { [s] }


stmt[stmt] = 
    # comment
    / function_def
    / async_function_def
    / class_def
    / return_stmt
    / delete_stmt
    / assign
    / ann_assign
    / for_stmt
    / async_for
    / while_stmt
    / if_stmt
    # / with_stmt # TODO
    # / async_with
    / expr_stmt

# comment[Comment] =  
# 	'#' x:comment_item* { Comment(value=''.join(str(x.string) for x in x)) }	

# comment_item[tokenize.TokenInfo] = 
#     NAME
#     / " "
#     / "\t"

# TODO: returns
function_def[FunctionDef] =
    d:decorators? _ 'def' _ n:id _ '(' _ a:args _ ')' _ ellipsis? { FunctionDef(name=n, decorator_list=d or []) }

async_function_def[AsyncFunctionDef] =
    d:decorators? _ 'async' _ 'def' _ n:id _ '(' _ a:args _ ')' _ ellipsis? { AsyncFunctionDef(name=n, decorator_list=d or []) }

class_def[ClassDef] =
    d:decorators? _ 'class' _ n:id _ bases:class_bases? _ ellipsis? { ClassDef(name=n, bases=bases or [], decorator_list=d or []) }

return_stmt[Return] =
    'return' _ e:expr { Return(value=e) }

delete_stmt[Delete] =
    'delete' _ e:exprs { Delete(targets=e) }

assign[Assign] =
    targets:exprs _ '=' _ value:expr { Assign(targets=targets, value=value) }

ann_assign[AnnAssign] =
    target[Name | Attribute | Subscript]:expr _ ':' _ ann:expr _ '=' _ value:expr { AnnAssign(target=target, annotation=ann, value=value) }

for_stmt[For] =
    'for' _ target:expr _ 'in' _ iter:expr _ ellipsis? { For(target=target, iter=iter) }

async_for[AsyncFor] =
    'async' _ 'for' _ target:expr _ 'in' _ iter:expr _ ellipsis? { AsyncFor(target=target, iter=iter) }

while_stmt[While] =
    'while' _ test:expr _ ellipsis? { While(test=test) }

if_stmt[If] =
    'if' _ test:expr _ ('=' _ ellipsis?)? { If(test=test) }

# with_stmt[With] =
#     'with' _ items:withitem* _ ('=' _ ellipsis?)? { With(items=items) }

# async_with[AsyncWith] =
#     'async' _ 'with' _ items:withitem* _ ('=' _ ellipsis?)? { AsyncWith(items=items) }

expr_stmt[Expr] =
    e:expr _ { Expr(value=e) }

decorators[list[ASTPattern[expr]]] =
    '\n'.decorator+ 

decorator[ASTPattern[expr]] =
    '@' _ e:expr { e }

class_bases[list[ASTPattern[expr]]] = 
    '(' _ e:exprs _ ')' {e}

exprs[list[ASTPattern[expr]]] =
    e:','.expr+ ','? {e}

#TODO
args = 'TODO' 

# withitem[WithItem] =
#     ctx:expr _ ('as' _ vars:expr)? { WithItem(context_expr=ctx, optional_vars=vars) }

expr[ASTPattern[expr]] =
    c:capture_pattern s:suffix* { _reduce_chain(c, s) }
    / chain

capture_pattern[Capture[ASTPattern[expr]]] =
    c:capture _ '{' _ pattern:chain _ '}' { Capture(name=c, pattern=pattern) }

chain[ASTPattern[expr]] =
    p:primary s:suffix* { _reduce_chain(p, s) }

suffix[dict] =
    call_suffix
    / attr_suffix
    / subscript_suffix

# TODO: kwargs
call_suffix[dict] =
    '(' _ args:exprs? _ ')' { { 'type': 'Call', 'args': args or [] } }

attr_suffix[dict] =
    '.' _ attr:id { { 'type': 'Attribute', 'attr': attr } }

subscript_suffix[dict] =
    '[' _ slice:expr _ ']' { { 'type': 'Subscript', 'slice': slice } }

primary[ASTPattern[expr]] =
    constant
    / dict_expr
    / set_expr
    / await_expr
    / list_expr
    / tuple_expr
    / wildcard
    / name_expr
    / c:capture_id { Capture(name=c.name, pattern=expr()) }
    / w:wildcard_id { Name() }

dict_expr[Dict] =
    '{' _ d:dict _ '}' { Dict(keys=d[0], values=d[1]) }

set_expr[Set] =
    '{' _ e:exprs? _ '}' { Set(elts=e or []) }

await_expr[Await] =
    'await' _ e:expr { Await(value=e) }

list_expr[List] =
    '[' _ e:exprs? _ ']' { List(elts=e or []) }

tuple_expr[Tuple] =
    '(' _ e:exprs? _ ')' { Tuple(elts=e or []) }

wildcard[Wildcard] =
    '~' { Wildcard() }

# TODO: kwargs
dict[tuple[list[ASTPattern[expr|None]], list[ASTPattern[expr]]]] =
    head:(k:expr _ ':' _ v:expr) tail:(',' _ k:expr _ ':' _ v:expr)* {
        _make_dict(head, tail)
    }

name_expr[Name] =
    n:NAME { Name(id=n.string) }


id[Capture[_Identifier]|WildcardId|_Identifier] = 
    capture_id
    / n:NAME { n.string }
    / wildcard_id

capture_id[Capture] =
    c:capture { Capture(name=c, pattern=WildcardId()) }

wildcard_id[WildcardId] =
    '`' { WildcardId() }

capture[str] =
    '$' _ n:NAME { n.string }

ellipsis[Any] =
    ':'
    / ':' _ '...' 

constant[Constant] =
    'None' { Constant(value=None) }
    / 'True' { Constant(value=True) }
    / 'False' { Constant(value=False) }
    / n:NUMBER { Constant(value=ast.literal_eval(n.string)) }
    / s:STRING { Constant(value=s.string) }

NUMBER = 
    float
    / integer

integer =
    digits:DIGIT+ { return parseInt(digits.join(''), 10) }

float =
    int:DIGIT+ '.' dec:DIGIT+ { 
        return parseFloat(int.join('') + '.' + dec.join('')) 
    }

STRING = 
    single_quoted
    / double_quoted

single_quoted =
    "'" chars:CHAR* "'" { return chars.join('') }

double_quoted =
    '"' chars:CHAR* '"' { return chars.join('') }


DIGIT = '0' / '1' / '2' / '3' / '4' / '5' / '6' / '7' / '8' / '9'
LETTER = 'a' / 'b' / 'c' / 'd' / 'e' / 'f' / 'g' / 'h' / 'i' / 'j' / 'k' / 'l' / 'm' / 'n' / 'o' / 'p' / 'q' / 'r' / 's' / 't' / 'u' / 'v' / 'w' / 'x' / 'y' / 'z' / 'A' / 'B' / 'C' / 'D' / 'E' / 'F' / 'G' / 'H' / 'I' / 'J' / 'K' / 'L' / 'M' / 'N' / 'O' / 'P' / 'Q' / 'R' / 'S' / 'T' / 'U' / 'V' / 'W' / 'X' / 'Y' / 'Z'
CHAR = DIGIT / LETTER

NAME = chars:LETTER+ { return chars.join('') }

_ = ' ' _ / '\t' _


