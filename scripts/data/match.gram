# TODO: args
# TODO: $0
# TODO: invalid syntax message
# TODO: is this ambiguous? $a{}
# TODO: specify type (especially Constant)
# TODO? use different actions to generate test cases
# TODO: maybe support body
# TODO: maybe just use normal grammar parser
# ? Use _ for typing?
# $<>, $[], $()
# TODO: I forgot why cannot use ~ for wildcard id
# TODO: uop, op
# TODO: match stmt
# TODO: or use $ for wildcard?
# TODO: (~) should match one or any (maybe ~?, ~+, ~*)
# TODO? $[type]name{}
# TODO? $0.a (maybe we have to customize the tokenizer)


@class"DSLParser"

@header"""\
#!/usr/bin/env python3.8
# @generated by pegen from {filename}
# pyright: reportUnusedVariable=false, reportUnusedImport=false, reportIncompatibleMethodOverride=false, reportUnusedParameter=false
# ruff: noqa: F401, F841, E703, F405, F403, F634

from __future__ import annotations


import ast
import sys
import tokenize

from typing import Any, Optional, TYPE_CHECKING, cast

from rich import print
from pegen.parser import memoize, memoize_left_rec, logger, Parser
from functools import reduce, wraps
"""


@subheader"""\
from .parser_helpers import *
from .nodes import *

def wrap_start(fn):
    @wraps(fn)
    def wrapper(self, *args, **kwargs):
        ret = fn(self, *args, **kwargs)
        return ret
    return wrapper

def wrap_stmt(fn):
    @wraps(fn)
    def wrapper(self, *args, **kwargs):
        lineno = self._tokenizer.peek().start[0]
        ret = fn(self, *args, **kwargs)
        return ret
    return wrapper

def _reduce_chain(p, s):
    def reducer(acc, suffix):
        if suffix['type'] == 'Call':
            return Call(func=acc, args=suffix['args'])
        if suffix['type'] == 'Attribute':
            return Attribute(value=acc, attr=suffix['attr'])
        if suffix['type'] == 'Subscript':
            return Subscript(value=acc, slice=suffix['slice'])
        return acc
    
    return reduce(reducer, s, p)

def _make_dict(head, tail):
    return tuple(zip(*[head] + [(k, v) for _, k, __, v in tail]))

"""

todo: 'todo' { _Todo()}


start: stmts ENDMARKER { stmts }

stmts[list[stmt]]: 
    | s=stmt '\n' rest=stmts {[s, *rest]}     
    | s=stmt '\n' { [s] }
    | s=stmt { [s] }

stmt[stmt]: 
    | function_def
    | async_function_def
    | class_def
    | return_stmt
    | delete_stmt
    | assign
    | ann_assign
    | for_stmt
    | async_for
    | while_stmt
    | if_stmt
    | expr_stmt

function_def[FunctionDef]:
    # | d=decorators?  'def'  n=id  '('  a=args?  ')'  ellipsis? { FunctionDef(name=n, decorator_list=d or [], args=a or arguments.make_empty()) }
    # | d=decorators?  'def'  n=id  '('  a=args?  ')'  ellipsis? { FunctionDef(name=n, decorator_list=d or [], args=a or Wildcard()) }

    | 'def' n=id t=[type_params] '(' params=params? ')' a=['->' z=expression { z }] ':' '...' {
        FunctionDef(name=n, decorator_list=[], args=params or arguments.make_empty())
    }


async_function_def[AsyncFunctionDef]:
    | d=decorators?  'async'  'def'  n=id  '('  a=params?  ')'  ellipsis? { AsyncFunctionDef(name=n, decorator_list=d or [], args=a or arguments.make_empty()) }

class_def[ClassDef]:
    | d=decorators?  'class'  n=id  bases=class_bases?  ellipsis? { ClassDef(name=n, bases=bases or [], decorator_list=d or []) }

return_stmt[Return]:
    | 'return'  e=expr { Return(value=e) }

delete_stmt[Delete]:
    | 'delete'  e=exprs { Delete(targets=e) }

assign[Assign]:
    | targets=exprs  '='  value=expr { Assign(targets=targets, value=value) }

ann_assign[AnnAssign]:
    | target[Name|Attribute|Subscript]=expr  ':'  ann=expr  '='  value=expr { AnnAssign(target=target, annotation=ann, value=value) }

for_stmt[For]:
    | 'for'  target=expr  'in'  iter=expr  ellipsis? { For(target=target, iter=iter) }

async_for[AsyncFor]:
    | 'async'  'for'  target=expr  'in'  iter=expr  ellipsis? { AsyncFor(target=target, iter=iter) }

while_stmt[While]:
    | 'while'  test=expr  ellipsis? { While(test=test) }

if_stmt[If]:
    | 'if'  test=expr  ('='  ellipsis?)? { If(test=test) }

expr_stmt[Expr]:
    | e=expr  { Expr(value=e) }

decorators[list[ASTPattern[expr]]]:
    | '\n'.decorator+

decorator[ASTPattern[expr]]:
    | '@'  e=expr { e }

class_bases[list[ASTPattern[expr]]]: 
    | '('  e=exprs  ')' {e}

# TODO
# args[arguments]: exprs

ellipsis[Any]:
    | ':'  '...'
    | ':'

# --------------------------------- Function --------------------------------- #

# ? No default => wildcard or empty

type_params[list[ASTPattern[expr]]]:
    | todo


### 1.
params[ASTPattern[arguments]]:
    # | wildcards0 { Wildcard() }
    # | wildcards1 { "never" } # TODO
    | parameters

parameters[ASTPattern[arguments]]:
    | a=slash_no_default b=param_no_default* c=param_with_default* d=[star_etc] {
        make_arguments(
            slash_without_default=a,
            plain_names=b,
            names_with_default=c,
            star_etc=d,
        )
      }
    | a=slash_with_default b=param_with_default* c=[star_etc] {
        make_arguments(
            slash_with_default=a,
            names_with_default=b,
            star_etc=c,
        )
      }
    | a=param_no_default+ b=param_with_default* c=[star_etc] {
        make_arguments(
            plain_names=a,
            names_with_default=b,
            star_etc=c,
        )
      }
    | a=param_with_default+ b=[star_etc] {
        make_arguments(
            names_with_default=a,
            star_etc=b,
        )
      }
    | a=star_etc {
        make_arguments(star_etc=a)
    }

### 2.
slash_no_default[list[arg]]:
    | a=param_no_default+ '/' ',' { a }
    | a=param_no_default+ '/' &')' { a }
slash_with_default[SlashWithDefault]:
    | a=param_no_default* b=param_with_default+ '/' ',' { SlashWithDefault(a, b) }
    | a=param_no_default* b=param_with_default+ '/' &')' { SlashWithDefault(a, b) }

star_etc[StarEtc]:
    | '*' a=param_no_default b=param_maybe_default* c=[kwds] { StarEtc(a, b, c) }
    | '*' a=param_no_default_star_annotation b=param_maybe_default* c=[kwds] { StarEtc(a, b, c) }
    | '*' ',' b=param_maybe_default+ c=[kwds] { StarEtc(None, b, c) }
    | a=kwds { StarEtc(None, [], a) }

kwds[ASTPattern[arg]]:
    | '**' a=param_no_default { a }

### 3.
param_no_default[ASTPattern[arg]]:
    | a=param ','  { a }
    | a=param  &')' { a }
param_no_default_star_annotation[ASTPattern[arg]]:
    | a=param_star_annotation ','  { a }
    | a=param_star_annotation &')' { a }
param_with_default[NameDefaultPair]:
    | a=param c=default ','  { NameDefaultPair(a, c) }
    | a=param c=default  &')' { NameDefaultPair(a, c) }
param_maybe_default[NameDefaultPair]:
    | a=param c=default? ','  { NameDefaultPair(a, c) }
    | a=param c=default? &')' { NameDefaultPair(a, c) }

param[ASTPattern[arg]]: a=NAME b=annotation? { arg(arg=a.string, annotation=b or Wildcard()) }
param_star_annotation[ASTPattern[arg]]: todo
annotation[ASTPattern[expr]]: ':' a=expression { a }
star_annotation[ASTPattern[expr]]: todo
default[ASTPattern[expr]]: '=' a=expression { a } 

# ------------------------------- Expressions ------------------------------ #

exprs[list[ASTPattern[expr]]]:
    |  wildcards0 { WildcardRepeat0() }
    |  wildcards1 { WildcardRepeat1() }
    # TODO: where is exprs used?
    | !(expr ','? ')') '$' n=NAME '{' pattern=( exprs) '}' { Capture(name=n.string, pattern=pattern) }
    | !(expr ','? ')') '$' n=NUMBER '{' pattern=( exprs) '}' { Capture(name=int(n.string), pattern=pattern) }
    | a[list[ASTPattern[expr]]]=','.expr+ ','? { a }

expr[ASTPattern[expr]]:
    | a=disjunction 'if' b=disjunction 'else' c=expr { IfExp(a,b,c) }
    | disjunction
    | lambdef

expression: expr

yield_expr[ASTPattern[expr]]:
    | 'yield' 'from' a=expr { YieldFrom(a) }
    | 'yield' a=star_exprs? { Yield(a) }

star_exprs[list[ASTPattern[expr]]]:
    | a=exprs ',' { a }

star_expr[ASTPattern[expr]]:
    | '*' a=bitwise_or { Starred(a) }
    | expr

star_named_exprs[list[ASTPattern[expr]]]: a[list[ASTPattern[expr]]]=','.star_named_expr+ ','? { a }

star_named_expr[ASTPattern[expr]]:
    | '*' a=bitwise_or { Starred(a) }
    | named_expr

assignment_expr[ASTPattern[expr]]:
    | a=NAME ':=' ~ b=expr { NamedExpr(target=a, value=b) }

named_expr[ASTPattern[expr]]:
    | assignment_expr
    | expr !':='

disjunction[ASTPattern[expr]]:
    | a=conjunction b=('or'  c=conjunction { c })+ { BoolOp(op=Or(), values=[a, *b]) }
    | conjunction

conjunction[ASTPattern[expr]]:
    | a=inversion b=('and'  c=inversion { c })+ { BoolOp(op=And(), values=[a, *b]) }
    | inversion

inversion[ASTPattern[expr]]:
    | 'not'  a=inversion { UnaryOp(op=Not(), operand=a) }
    | comparison

comparison[ASTPattern[expr]]:
    | a=bitwise_or b=compare_op_bitwise_or_pair+ {
        Compare(
            left=a,
            ops=[pair['op'] for pair in b],
            comparators=[pair['comparator'] for pair in b]
        )
    }
    | bitwise_or

compare_op_bitwise_or_pair[dict]:
    | '=='  b=bitwise_or { {'op': Eq(), 'comparator': b} }
    | '!='  b=bitwise_or { {'op': NotEq(), 'comparator': b} }
    | '<='  b=bitwise_or { {'op': LtE(), 'comparator': b} }
    | '<'  b=bitwise_or { {'op': Lt(), 'comparator': b} }
    | '>='  b=bitwise_or { {'op': GtE(), 'comparator': b} }
    | '>'  b=bitwise_or { {'op': Gt(), 'comparator': b} }
    | 'not'  'in'  b=bitwise_or { {'op': NotIn(), 'comparator': b} }
    | 'in'  b=bitwise_or { {'op': In(), 'comparator': b} }
    | 'is'  'not'  b=bitwise_or { {'op': IsNot(), 'comparator': b} }
    | 'is'  b=bitwise_or { {'op': Is(), 'comparator': b} }

bitwise_or[ASTPattern[expr]]:
    | a=bitwise_or '|'  b=bitwise_xor { BinOp(left=a, op=BitOr(), right=b) }
    | bitwise_xor

bitwise_xor[ASTPattern[expr]]:
    | a=bitwise_xor '^'  b=bitwise_and { BinOp(left=a, op=BitXor(), right=b) }
    | bitwise_and

bitwise_and[ASTPattern[expr]]:
    | a=bitwise_and '&'  b=shift_expr { BinOp(left=a, op=BitAnd(), right=b) }
    | shift_expr

shift_expr[ASTPattern[expr]]:
    | a=shift_expr '<<'  b=sum { BinOp(left=a, op=LShift(), right=b) }
    | a=shift_expr '>>'  b=sum { BinOp(left=a, op=RShift(), right=b) }
    | sum

sum[ASTPattern[expr]]:
    | a=sum '+'  b=term { BinOp(left=a, op=Add(), right=b) }
    | a=sum '-'  b=term { BinOp(left=a, op=Sub(), right=b) }
    | term

term[ASTPattern[expr]]:
    | a=term '*'  b=factor { BinOp(left=a, op=Mult(), right=b) }
    | a=term '/'  b=factor { BinOp(left=a, op=Div(), right=b) }
    | a=term '//'  b=factor { BinOp(left=a, op=FloorDiv(), right=b) }
    | a=term '%'  b=factor { BinOp(left=a, op=Mod(), right=b) }
    | a=term '@'  b=factor { BinOp(left=a, op=MatMult(), right=b) }
    | factor

factor[ASTPattern[expr]]:
    | '+'  a=factor { UnaryOp(op=UAdd(), operand=a) }
    | '-'  a=factor { UnaryOp(op=USub(), operand=a) }
    # | '~' a=factor { UnaryOp(op=Invert(), operand=a) }
    | power

power[ASTPattern[expr]]:
    | a=await_primary '**'  b=factor { BinOp(left=a, op=Pow(), right=b) }
    | await_primary

await_primary[ASTPattern[expr]]:
    | 'await'  a=primary { Await(value=a) }
    | primary

primary[ASTPattern[expr]]:
    | a=primary '.'  b=id { Attribute(value=a, attr=b) }
    | a=primary '('  args=exprs?  ')' { Call(func=a, args=args or []) }
    | a=primary '['  b=expr  ']' { Subscript(value=a, slice=b) }
    | atom

atom[ASTPattern[expr]]:
    | name_expr
    | constant
    | &'(' (tuple | group | genexp)
    | &'[' (list | listcomp)
    | &'{' (dict | set | dictcomp | setcomp)
    | wildcard
    | wildcard_id
    | c=capture_pattern 
    | c=capture_id { Capture(name=c.name, pattern=expr()) }

group[expr_ty]:
    | '(' a=(yield_expr | named_expr) ')' { a }


# ---------------------------------- Lambda ---------------------------------- #

lambdef: todo
genexp: todo
listcomp: todo
setcomp: todo
dictcomp: todo

# --------------------------------- Literals --------------------------------- #

constant[Constant]:
    | 'None' { Constant(value=None) }
    | 'True' { Constant(value=True) }
    | 'False' { Constant(value=False) }
    | n=NUMBER { Constant(value=ast.literal_eval(n.string)) }
    | s=STRING { Constant(value=s.string) }
    | '...' { Constant(value=...) }

name_expr[Name]:
    | n=NAME { Name(id=n.string) }

tuple[Tuple]:
    | '(' a=exprs? ')' { Tuple(elts=a or []) }

list[List]:
    | '[' a=exprs? ']' { List(elts=a or []) }

set[Set]:
    | '{'  e=exprs?  '}' { Set(elts=e or []) }

# ----------------------------------- Dict ----------------------------------- #

dict[Dict]:
    | '{'  d=dict  '}' { Dict(keys=d[0], values=d[1]) }


# dict[tuple[list[ASTPattern[expr|None]], list[ASTPattern[expr]]]]:
#     | head=(k=expr  ':'  v=expr) tail=(','  k=expr  ':'  v=expr)* {
#         _make_dict(head, tail)
#     }

# ------------------------------- Custom Logic ------------------------------- #

id[Capture[_Identifier]|WildcardId|_Identifier]:
    | capture_id
    | n=NAME { n.string }
    | wildcard_id
    # | wildcard

capture_id[Capture]:
    | c=capture { Capture(name=c['name'], pattern=WildcardId()) }


wildcards0:
    | '~' '*'

wildcards1:
    | '~' '+'

wildcard[Wildcard]:
    | '~' { Wildcard() }

wildcard_id[WildcardId]:
    | '`' { WildcardId() }

capture[dict[str, str|int]]:
    | '$'  n=NAME { {'name': n.string} }
    | '$'  n=NUMBER { {'name': int(n.string)} }

capture_pattern[Capture[ASTPattern[expr]]]:
    | c=capture  '{'  pattern=expr  '}' { Capture(name=c['name'], pattern=pattern) }


