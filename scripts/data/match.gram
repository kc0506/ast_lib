# TODO: args
# TODO: $0
# TODO: invalid syntax message
# TODO: is this ambiguous? $a{}
# TODO: specify type (especially Constant)
# TODO? use different actions to generate test cases
# TODO: maybe support body
# TODO: maybe just use normal grammar parser
# ? Use _ for typing?
# $<>, $[], $()
# TODO: I forgot why cannot use ~ for wildcard id
# TODO: uop, op
# TODO: match stmt
# TODO: or use $ for wildcard?
# TODO: (~) should match one or any (maybe ~?, ~+, ~*)
# TODO? $[type]name{}
# TODO? $0.a (maybe we have to customize the tokenizer)


@class"DSLParser"

@header"""\
#!/usr/bin/env python3.8
# @generated by pegen from {filename}
# pyright: reportUnusedVariable=false, reportUnusedImport=false, reportIncompatibleMethodOverride=false, reportUnusedParameter=false
# ruff: noqa: F401, F841, E703, F405, F403, F634

from __future__ import annotations


import ast
import sys
import tokenize

from typing import Any, Optional, TYPE_CHECKING, cast

from rich import print
from pegen.parser import memoize, memoize_left_rec, logger, Parser
"""


@subheader"""\
from functools import reduce, wraps
from .nodes import *

def wrap_start(fn):
    @wraps(fn)
    def wrapper(self, *args, **kwargs):
        ret = fn(self, *args, **kwargs)
        return ret
    return wrapper

def wrap_stmt(fn):
    @wraps(fn)
    def wrapper(self, *args, **kwargs):
        lineno = self._tokenizer.peek().start[0]
        ret = fn(self, *args, **kwargs)
        return ret
    return wrapper

def _reduce_chain(p, s):
    def reducer(acc, suffix):
        if suffix['type'] == 'Call':
            return Call(func=acc, args=suffix['args'])
        if suffix['type'] == 'Attribute':
            return Attribute(value=acc, attr=suffix['attr'])
        if suffix['type'] == 'Subscript':
            return Subscript(value=acc, slice=suffix['slice'])
        return acc
    
    return reduce(reducer, s, p)

def _make_dict(head, tail):
    return tuple(zip(*[head] + [(k, v) for _, k, __, v in tail]))

"""

start: stmts ENDMARKER { stmts }

stmts[list[stmt]]: 
    | s=stmt '\n' rest=stmts {[s, *rest]}     
    | s=stmt '\n' { [s] }
    | s=stmt { [s] }

stmt[stmt]: 
    | function_def
    | async_function_def
    | class_def
    | return_stmt
    | delete_stmt
    | assign
    | ann_assign
    | for_stmt
    | async_for
    | while_stmt
    | if_stmt
    | expr_stmt

function_def[FunctionDef]:
    # | d=decorators?  'def'  n=id  '('  a=args?  ')'  ellipsis? { FunctionDef(name=n, decorator_list=d or [], args=a or arguments.make_empty()) }
    | d=decorators?  'def'  n=id  '('  a=args?  ')'  ellipsis? { FunctionDef(name=n, decorator_list=d or [], args=a or Wildcard()) }

async_function_def[AsyncFunctionDef]:
    | d=decorators?  'async'  'def'  n=id  '('  a=args?  ')'  ellipsis? { AsyncFunctionDef(name=n, decorator_list=d or [], args=a or arguments.make_empty()) }

class_def[ClassDef]:
    | d=decorators?  'class'  n=id  bases=class_bases?  ellipsis? { ClassDef(name=n, bases=bases or [], decorator_list=d or []) }

return_stmt[Return]:
    | 'return'  e=expr { Return(value=e) }

delete_stmt[Delete]:
    | 'delete'  e=exprs { Delete(targets=e) }

assign[Assign]:
    | targets=exprs  '='  value=expr { Assign(targets=targets, value=value) }

ann_assign[AnnAssign]:
    | target[Name|Attribute|Subscript]=expr  ':'  ann=expr  '='  value=expr { AnnAssign(target=target, annotation=ann, value=value) }

for_stmt[For]:
    | 'for'  target=expr  'in'  iter=expr  ellipsis? { For(target=target, iter=iter) }

async_for[AsyncFor]:
    | 'async'  'for'  target=expr  'in'  iter=expr  ellipsis? { AsyncFor(target=target, iter=iter) }

while_stmt[While]:
    | 'while'  test=expr  ellipsis? { While(test=test) }

if_stmt[If]:
    | 'if'  test=expr  ('='  ellipsis?)? { If(test=test) }

expr_stmt[Expr]:
    | e=expr  { Expr(value=e) }

decorators[list[ASTPattern[expr]]]:
    | '\n'.decorator+

decorator[ASTPattern[expr]]:
    | '@'  e=expr { e }

class_bases[list[ASTPattern[expr]]]: 
    | '('  e=exprs  ')' {e}

exprs[list[ASTPattern[expr]]]:
    | e=','.expr+ ','? {e}

args[arguments]: exprs

expr[ASTPattern[expr]]:
    | disjunction

disjunction[ASTPattern[expr]]:
    | a=conjunction b=('or'  c=conjunction { c })+ { BoolOp(op=Or(), values=[a, *b]) }
    | conjunction

conjunction[ASTPattern[expr]]:
    | a=inversion b=('and'  c=inversion { c })+ { BoolOp(op=And(), values=[a, *b]) }
    | inversion

inversion[ASTPattern[expr]]:
    | 'not'  a=inversion { UnaryOp(op=Not(), operand=a) }
    | comparison

comparison[ASTPattern[expr]]:
    | a=bitwise_or b=compare_op_bitwise_or_pair+ {
        Compare(
            left=a,
            ops=[pair['op'] for pair in b],
            comparators=[pair['comparator'] for pair in b]
        )
    }
    | bitwise_or

compare_op_bitwise_or_pair[dict]:
    | '=='  b=bitwise_or { {'op': Eq(), 'comparator': b} }
    | '!='  b=bitwise_or { {'op': NotEq(), 'comparator': b} }
    | '<='  b=bitwise_or { {'op': LtE(), 'comparator': b} }
    | '<'  b=bitwise_or { {'op': Lt(), 'comparator': b} }
    | '>='  b=bitwise_or { {'op': GtE(), 'comparator': b} }
    | '>'  b=bitwise_or { {'op': Gt(), 'comparator': b} }
    | 'not'  'in'  b=bitwise_or { {'op': NotIn(), 'comparator': b} }
    | 'in'  b=bitwise_or { {'op': In(), 'comparator': b} }
    | 'is'  'not'  b=bitwise_or { {'op': IsNot(), 'comparator': b} }
    | 'is'  b=bitwise_or { {'op': Is(), 'comparator': b} }

bitwise_or[ASTPattern[expr]]:
    | a=bitwise_or '|'  b=bitwise_xor { BinOp(left=a, op=BitOr(), right=b) }
    | bitwise_xor

bitwise_xor[ASTPattern[expr]]:
    | a=bitwise_xor '^'  b=bitwise_and { BinOp(left=a, op=BitXor(), right=b) }
    | bitwise_and

bitwise_and[ASTPattern[expr]]:
    | a=bitwise_and '&'  b=shift_expr { BinOp(left=a, op=BitAnd(), right=b) }
    | shift_expr

shift_expr[ASTPattern[expr]]:
    | a=shift_expr '<<'  b=sum { BinOp(left=a, op=LShift(), right=b) }
    | a=shift_expr '>>'  b=sum { BinOp(left=a, op=RShift(), right=b) }
    | sum

sum[ASTPattern[expr]]:
    | a=sum '+'  b=term { BinOp(left=a, op=Add(), right=b) }
    | a=sum '-'  b=term { BinOp(left=a, op=Sub(), right=b) }
    | term

term[ASTPattern[expr]]:
    | a=term '*'  b=factor { BinOp(left=a, op=Mult(), right=b) }
    | a=term '/'  b=factor { BinOp(left=a, op=Div(), right=b) }
    | a=term '//'  b=factor { BinOp(left=a, op=FloorDiv(), right=b) }
    | a=term '%'  b=factor { BinOp(left=a, op=Mod(), right=b) }
    | a=term '@'  b=factor { BinOp(left=a, op=MatMult(), right=b) }
    | factor

factor[ASTPattern[expr]]:
    | '+'  a=factor { UnaryOp(op=UAdd(), operand=a) }
    | '-'  a=factor { UnaryOp(op=USub(), operand=a) }
    # | '~' a=factor { UnaryOp(op=Invert(), operand=a) }
    | power

power[ASTPattern[expr]]:
    | a=await_primary '**'  b=factor { BinOp(left=a, op=Pow(), right=b) }
    | await_primary

await_primary[ASTPattern[expr]]:
    | 'await'  a=primary { Await(value=a) }
    | primary

primary[ASTPattern[expr]]:
    | a=primary '.'  b=id { Attribute(value=a, attr=b) }
    | a=primary '('  args=exprs?  ')' { Call(func=a, args=args or Wildcard()) }
    | a=primary '['  b=expr  ']' { Subscript(value=a, slice=b) }
    | atom

atom[ASTPattern[expr]]:
    | constant
    | dict_expr
    | set_expr
    | list_expr
    | tuple_expr
    | wildcard
    | name_expr
    | c=capture_pattern 
    | c=capture_id { Capture(name=c.name, pattern=expr()) }
    | w=wildcard_id { Name() }


capture_pattern[Capture[ASTPattern[expr]]]:
    | c=capture  '{'  pattern=expr  '}' { Capture(name=c['name'], pattern=pattern) }


list_expr[List]:
    | '[' a=exprs? ']' { List(elts=a or []) }

tuple_expr[Tuple]:
    | '(' a=exprs? ')' { Tuple(elts=a or []) }


dict_expr[Dict]:
    | '{'  d=dict  '}' { Dict(keys=d[0], values=d[1]) }

set_expr[Set]:
    | '{'  e=exprs?  '}' { Set(elts=e or []) }

wildcard[Wildcard]:
    | '~' { Wildcard() }

dict[tuple[list[ASTPattern[expr|None]], list[ASTPattern[expr]]]]:
    | head=(k=expr  ':'  v=expr) tail=(','  k=expr  ':'  v=expr)* {
        _make_dict(head, tail)
    }

name_expr[Name]:
    | n=NAME { Name(id=n.string) }

id[Capture[_Identifier]|WildcardId|_Identifier]:
    | capture_id
    | n=NAME { n.string }
    | wildcard_id

capture_id[Capture]:
    | c=capture { Capture(name=c['name'], pattern=WildcardId()) }

wildcard_id[WildcardId]:
    | '`' { WildcardId() }

capture[dict[str, str|int]]:
    | '$'  n=NAME { {'name': n.string} }
    | '$'  n=NUMBER { {'name': int(n.string)} }

ellipsis[Any]:
    | ':'  '...'
    | ':'

constant[Constant]:
    | 'None' { Constant(value=None) }
    | 'True' { Constant(value=True) }
    | 'False' { Constant(value=False) }
    | n=NUMBER { Constant(value=ast.literal_eval(n.string)) }
    | s=STRING { Constant(value=s.string) }
